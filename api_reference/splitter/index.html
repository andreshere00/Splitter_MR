
<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      
      
      
      
        <link rel="prev" href="../reader/">
      
      
        <link rel="next" href="../model/">
      
      
      <link rel="icon" href="../../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.6.1, mkdocs-material-9.6.19">
    
    
      
        <title>Splitters - SplitterMR Docs</title>
      
    
    
      <link rel="stylesheet" href="../../assets/stylesheets/main.7e37652d.min.css">
      
        
        <link rel="stylesheet" href="../../assets/stylesheets/palette.06af60db.min.css">
      
      


    
    
      
    
    
      
        
        
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Sans+3:300,300i,400,400i,700,700i%7CRoboto+Mono:400,400i,700,700i&display=fallback">
        <style>:root{--md-text-font:"Source Sans 3";--md-code-font:"Roboto Mono"}</style>
      
    
    
      <link rel="stylesheet" href="../../assets/_mkdocstrings.css">
    
      <link rel="stylesheet" href="https://unpkg.com/katex@0/dist/katex.min.css">
    
      <link rel="stylesheet" href="../../assets/extra.css">
    
    <script>__md_scope=new URL("../..",location),__md_hash=e=>[...e].reduce(((e,_)=>(e<<5)-e+_.charCodeAt(0)),0),__md_get=(e,_=localStorage,t=__md_scope)=>JSON.parse(_.getItem(t.pathname+"."+e)),__md_set=(e,_,t=localStorage,a=__md_scope)=>{try{t.setItem(a.pathname+"."+e,JSON.stringify(_))}catch(e){}}</script>
    
      

    
    
    
  </head>
  
  
    
    
      
    
    
    
    
    <body dir="ltr" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo">
  
    
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" for="__drawer"></label>
    <div data-md-component="skip">
      
        
        <a href="#splitter" class="md-skip">
          Skip to content
        </a>
      
    </div>
    <div data-md-component="announce">
      
    </div>
    
    
      

  

<header class="md-header md-header--shadow" data-md-component="header">
  <nav class="md-header__inner md-grid" aria-label="Header">
    <a href="../.." title="SplitterMR Docs" class="md-header__button md-logo" aria-label="SplitterMR Docs" data-md-component="logo">
      
  <img src="../../assets/splitter_mr_logo_reduced_white.svg" alt="logo">

    </a>
    <label class="md-header__button md-icon" for="__drawer">
      
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M3 6h18v2H3zm0 5h18v2H3zm0 5h18v2H3z"/></svg>
    </label>
    <div class="md-header__title" data-md-component="header-title">
      <div class="md-header__ellipsis">
        <div class="md-header__topic">
          <span class="md-ellipsis">
            SplitterMR Docs
          </span>
        </div>
        <div class="md-header__topic" data-md-component="header-topic">
          <span class="md-ellipsis">
            
              Splitters
            
          </span>
        </div>
      </div>
    </div>
    
      
        <form class="md-header__option" data-md-component="palette">
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="default" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to dark mode"  type="radio" name="__palette" id="__palette_0">
    
      <label class="md-header__button md-icon" title="Switch to dark mode" for="__palette_1" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 8a4 4 0 0 0-4 4 4 4 0 0 0 4 4 4 4 0 0 0 4-4 4 4 0 0 0-4-4m0 10a6 6 0 0 1-6-6 6 6 0 0 1 6-6 6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
    
    
    
    <input class="md-option" data-md-color-media="" data-md-color-scheme="slate" data-md-color-primary="indigo" data-md-color-accent="indigo"  aria-label="Switch to light mode"  type="radio" name="__palette" id="__palette_1">
    
      <label class="md-header__button md-icon" title="Switch to light mode" for="__palette_0" hidden>
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M12 18c-.89 0-1.74-.2-2.5-.55C11.56 16.5 13 14.42 13 12s-1.44-4.5-3.5-5.45C10.26 6.2 11.11 6 12 6a6 6 0 0 1 6 6 6 6 0 0 1-6 6m8-9.31V4h-4.69L12 .69 8.69 4H4v4.69L.69 12 4 15.31V20h4.69L12 23.31 15.31 20H20v-4.69L23.31 12z"/></svg>
      </label>
    
  
</form>
      
    
    
      <script>var palette=__md_get("__palette");if(palette&&palette.color){if("(prefers-color-scheme)"===palette.color.media){var media=matchMedia("(prefers-color-scheme: light)"),input=document.querySelector(media.matches?"[data-md-color-media='(prefers-color-scheme: light)']":"[data-md-color-media='(prefers-color-scheme: dark)']");palette.color.media=input.getAttribute("data-md-color-media"),palette.color.scheme=input.getAttribute("data-md-color-scheme"),palette.color.primary=input.getAttribute("data-md-color-primary"),palette.color.accent=input.getAttribute("data-md-color-accent")}for(var[key,value]of Object.entries(palette.color))document.body.setAttribute("data-md-color-"+key,value)}</script>
    
    
    
      
      
        <label class="md-header__button md-icon" for="__search">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        </label>
        <div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" aria-label="Search" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="search-query" required>
      <label class="md-search__icon md-icon" for="__search">
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M9.5 3A6.5 6.5 0 0 1 16 9.5c0 1.61-.59 3.09-1.56 4.23l.27.27h.79l5 5-1.5 1.5-5-5v-.79l-.27-.27A6.52 6.52 0 0 1 9.5 16 6.5 6.5 0 0 1 3 9.5 6.5 6.5 0 0 1 9.5 3m0 2C7 5 5 7 5 9.5S7 14 9.5 14 14 12 14 9.5 12 5 9.5 5"/></svg>
        
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M20 11v2H8l5.5 5.5-1.42 1.42L4.16 12l7.92-7.92L13.5 5.5 8 11z"/></svg>
      </label>
      <nav class="md-search__options" aria-label="Search">
        
        <button type="reset" class="md-search__icon md-icon" title="Clear" aria-label="Clear" tabindex="-1">
          
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24"><path d="M19 6.41 17.59 5 12 10.59 6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 12 13.41 17.59 19 19 17.59 13.41 12z"/></svg>
        </button>
      </nav>
      
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" tabindex="0" data-md-scrollfix>
        <div class="md-search-result" data-md-component="search-result">
          <div class="md-search-result__meta">
            Initializing search
          </div>
          <ol class="md-search-result__list" role="presentation"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
      
    
    
      <div class="md-header__source">
        <a href="https://github.com/andreshere00/Splitter_MR" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    andreshere00/Splitter_MR
  </div>
</a>
      </div>
    
  </nav>
  
</header>
    
    <div class="md-container" data-md-component="container">
      
      
        
          
        
      
      <main class="md-main" data-md-component="main">
        <div class="md-main__inner md-grid">
          
            
              
              <div class="md-sidebar md-sidebar--primary" data-md-component="sidebar" data-md-type="navigation" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    



<nav class="md-nav md-nav--primary" aria-label="Navigation" data-md-level="0">
  <label class="md-nav__title" for="__drawer">
    <a href="../.." title="SplitterMR Docs" class="md-nav__button md-logo" aria-label="SplitterMR Docs" data-md-component="logo">
      
  <img src="../../assets/splitter_mr_logo_reduced_white.svg" alt="logo">

    </a>
    SplitterMR Docs
  </label>
  
    <div class="md-nav__source">
      <a href="https://github.com/andreshere00/Splitter_MR" title="Go to repository" class="md-source" data-md-component="source">
  <div class="md-source__icon md-icon">
    
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!--! Font Awesome Free 7.0.0 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) Copyright 2025 Fonticons, Inc.--><path fill="currentColor" d="M439.6 236.1 244 40.5c-5.4-5.5-12.8-8.5-20.4-8.5s-15 3-20.4 8.4L162.5 81l51.5 51.5c27.1-9.1 52.7 16.8 43.4 43.7l49.7 49.7c34.2-11.8 61.2 31 35.5 56.7-26.5 26.5-70.2-2.9-56-37.3L240.3 199v121.9c25.3 12.5 22.3 41.8 9.1 55-6.4 6.4-15.2 10.1-24.3 10.1s-17.8-3.6-24.3-10.1c-17.6-17.6-11.1-46.9 11.2-56v-123c-20.8-8.5-24.6-30.7-18.6-45L142.6 101 8.5 235.1C3 240.6 0 247.9 0 255.5s3 15 8.5 20.4l195.6 195.7c5.4 5.4 12.7 8.4 20.4 8.4s15-3 20.4-8.4l194.7-194.7c5.4-5.4 8.4-12.8 8.4-20.4s-3-15-8.4-20.4"/></svg>
  </div>
  <div class="md-source__repository">
    andreshere00/Splitter_MR
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../.." class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Home
    
  </span>
  

      </a>
    </li>
  

    
      
      
  
  
    
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--active md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_2" checked>
        
          
          <label class="md-nav__link" for="__nav_2" id="__nav_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Developer Guide
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_2_label" aria-expanded="true">
          <label class="md-nav__title" for="__nav_2">
            <span class="md-nav__icon md-icon"></span>
            Developer Guide
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../api_reference/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../reader/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Readers
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
    
  
  
  
    <li class="md-nav__item md-nav__item--active">
      
      <input class="md-nav__toggle md-toggle" type="checkbox" id="__toc">
      
      
        
      
      
        <label class="md-nav__link md-nav__link--active" for="__toc">
          
  
  
  <span class="md-ellipsis">
    Splitters
    
  </span>
  

          <span class="md-nav__icon md-icon"></span>
        </label>
      
      <a href="./" class="md-nav__link md-nav__link--active">
        
  
  
  <span class="md-ellipsis">
    Splitters
    
  </span>
  

      </a>
      
        

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter-strategies-description" class="md-nav__link">
    <span class="md-ellipsis">
      Splitter strategies description
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#output-format" class="md-nav__link">
    <span class="md-ellipsis">
      Output format
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Output format">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput" class="md-nav__link">
    <span class="md-ellipsis">
      SplitterOutput
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.validate_and_set_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_set_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.from_chunks" class="md-nav__link">
    <span class="md-ellipsis">
      from_chunks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.append_metadata" class="md-nav__link">
    <span class="md-ellipsis">
      append_metadata
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#splitters" class="md-nav__link">
    <span class="md-ellipsis">
      Splitters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Splitters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      BaseSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      base_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      BaseSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#charactersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      character_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wordsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      WordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="WordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      word_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      WordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="WordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sentencesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SentenceSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SentenceSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      sentence_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SentenceSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SentenceSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#paragraphsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      ParagraphSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParagraphSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      paragraph_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      ParagraphSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParagraphSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursivecharactersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveCharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveCharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      recursive_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveCharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveCharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#keywordsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      KeywordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KeywordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      keyword_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      KeywordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KeywordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#headersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HeaderSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HeaderSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      header_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HeaderSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HeaderSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursivejsonsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveJSONSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveJSONSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      json_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveJSONSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveJSONSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#htmltagsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HTMLTagSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HTMLTagSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      html_tag_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HTMLTagSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HTMLTagSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rowcolumnsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RowColumnSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RowColumnSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      row_column_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RowColumnSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RowColumnSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#codesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CodeSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CodeSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      code_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CodeSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CodeSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.get_langchain_language" class="md-nav__link">
    <span class="md-ellipsis">
      get_langchain_language
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tokensplitter" class="md-nav__link">
    <span class="md-ellipsis">
      TokenSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TokenSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      token_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      TokenSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TokenSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.list_nltk_punkt_languages" class="md-nav__link">
    <span class="md-ellipsis">
      list_nltk_punkt_languages
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pagedsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      PagedSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="PagedSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      paged_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      PagedSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="PagedSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#semanticsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SemanticSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SemanticSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      semantic_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SemanticSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SemanticSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../model/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Vision models
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../embedding/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Embedding models
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3" >
        
          
          <label class="md-nav__link" for="__nav_3" id="__nav_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Examples
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="1" aria-labelledby="__nav_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3">
            <span class="md-nav__icon md-icon"></span>
            Examples
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/examples/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Overview
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_2" >
        
          
          <label class="md-nav__link" for="__nav_3_2" id="__nav_3_2_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Reading
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_2_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_2">
            <span class="md-nav__icon md-icon"></span>
            Reading
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/pdf/pdf_without_vlm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read PDFs without VLMs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/pdf/pdf_with_vlm/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read PDFs using VLMs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/pdf/pdf_vanilla/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read files with VanillaReader using VLMs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/pdf/pdf_docling/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read files with Docling using VLMs
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/pdf/pdf_markitdown/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Read files with MarkItDown using VLMs
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_3" >
        
          
          <label class="md-nav__link" for="__nav_3_3" id="__nav_3_3_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Text-based splitting
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_3_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_3">
            <span class="md-nav__icon md-icon"></span>
            Text-based splitting
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/text/fixed_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by grammatical groups
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/text/recursive_character_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by characters recursively
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/text/token_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by tokens
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/text/paged_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by pages
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/text/semantic_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by semantic similarity
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
              
                
  
  
  
  
    
    
    
    
    
    <li class="md-nav__item md-nav__item--nested">
      
        
        
        <input class="md-nav__toggle md-toggle " type="checkbox" id="__nav_3_4" >
        
          
          <label class="md-nav__link" for="__nav_3_4" id="__nav_3_4_label" tabindex="0">
            
  
  
  <span class="md-ellipsis">
    Schema-based splitting
    
  </span>
  

            <span class="md-nav__icon md-icon"></span>
          </label>
        
        <nav class="md-nav" data-md-level="2" aria-labelledby="__nav_3_4_label" aria-expanded="false">
          <label class="md-nav__title" for="__nav_3_4">
            <span class="md-nav__icon md-icon"></span>
            Schema-based splitting
          </label>
          <ul class="md-nav__list" data-md-scrollfix>
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/schema/html_tag_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by HTML Tags
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/schema/code_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split by Code
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/schema/json_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split JSON recursively
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/schema/row_column_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split tables by rows or columns
    
  </span>
  

      </a>
    </li>
  

              
            
              
                
  
  
  
  
    <li class="md-nav__item">
      <a href="../../examples/schema/header_splitter/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    Split Markdown and HTML files by headers
    
  </span>
  

      </a>
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

              
            
          </ul>
        </nav>
      
    </li>
  

    
      
      
  
  
  
  
    <li class="md-nav__item">
      <a href="../../CHANGELOG/" class="md-nav__link">
        
  
  
  <span class="md-ellipsis">
    CHANGELOG
    
  </span>
  

      </a>
    </li>
  

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              
              <div class="md-sidebar md-sidebar--secondary" data-md-component="sidebar" data-md-type="toc" >
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    

<nav class="md-nav md-nav--secondary" aria-label="Table of contents">
  
  
  
    
  
  
    <label class="md-nav__title" for="__toc">
      <span class="md-nav__icon md-icon"></span>
      Table of contents
    </label>
    <ul class="md-nav__list" data-md-component="toc" data-md-scrollfix>
      
        <li class="md-nav__item">
  <a href="#introduction" class="md-nav__link">
    <span class="md-ellipsis">
      Introduction
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Introduction">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter-strategies-description" class="md-nav__link">
    <span class="md-ellipsis">
      Splitter strategies description
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#output-format" class="md-nav__link">
    <span class="md-ellipsis">
      Output format
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Output format">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput" class="md-nav__link">
    <span class="md-ellipsis">
      SplitterOutput
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.validate_and_set_defaults" class="md-nav__link">
    <span class="md-ellipsis">
      validate_and_set_defaults
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.from_chunks" class="md-nav__link">
    <span class="md-ellipsis">
      from_chunks
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.schema.models.SplitterOutput.append_metadata" class="md-nav__link">
    <span class="md-ellipsis">
      append_metadata
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
        <li class="md-nav__item">
  <a href="#splitters" class="md-nav__link">
    <span class="md-ellipsis">
      Splitters
    </span>
  </a>
  
    <nav class="md-nav" aria-label="Splitters">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#basesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      BaseSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      base_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      BaseSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="BaseSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.base_splitter.BaseSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#charactersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      character_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#wordsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      WordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="WordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      word_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      WordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="WordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#sentencesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SentenceSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SentenceSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      sentence_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SentenceSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SentenceSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#paragraphsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      ParagraphSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParagraphSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      paragraph_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      ParagraphSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="ParagraphSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursivecharactersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveCharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveCharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      recursive_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveCharacterSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveCharacterSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#keywordsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      KeywordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KeywordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      keyword_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      KeywordSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="KeywordSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#headersplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HeaderSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HeaderSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      header_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HeaderSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HeaderSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#recursivejsonsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveJSONSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveJSONSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      json_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RecursiveJSONSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RecursiveJSONSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#htmltagsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HTMLTagSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HTMLTagSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      html_tag_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      HTMLTagSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="HTMLTagSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#rowcolumnsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RowColumnSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RowColumnSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      row_column_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      RowColumnSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="RowColumnSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#codesplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CodeSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CodeSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      code_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      CodeSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="CodeSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.code_splitter.get_langchain_language" class="md-nav__link">
    <span class="md-ellipsis">
      get_langchain_language
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#tokensplitter" class="md-nav__link">
    <span class="md-ellipsis">
      TokenSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TokenSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      token_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      TokenSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="TokenSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.list_nltk_punkt_languages" class="md-nav__link">
    <span class="md-ellipsis">
      list_nltk_punkt_languages
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#pagedsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      PagedSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="PagedSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      paged_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      PagedSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="PagedSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
          <li class="md-nav__item">
  <a href="#semanticsplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SemanticSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SemanticSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter" class="md-nav__link">
    <span class="md-ellipsis">
      semantic_splitter
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter" class="md-nav__link">
    <span class="md-ellipsis">
      SemanticSplitter
    </span>
  </a>
  
    <nav class="md-nav" aria-label="SemanticSplitter">
      <ul class="md-nav__list">
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.__init__" class="md-nav__link">
    <span class="md-ellipsis">
      __init__
    </span>
  </a>
  
</li>
        
          <li class="md-nav__item">
  <a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.split" class="md-nav__link">
    <span class="md-ellipsis">
      split
    </span>
  </a>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
        
      </ul>
    </nav>
  
</li>
      
    </ul>
  
</nav>
                  </div>
                </div>
              </div>
            
          
          
            <div class="md-content" data-md-component="content">
              <article class="md-content__inner md-typeset">
                
                  


  
  


<h1 id="splitter"><strong>Splitter</strong><a class="headerlink" href="#splitter" title="Permanent link">&para;</a></h1>
<h2 id="introduction">Introduction<a class="headerlink" href="#introduction" title="Permanent link">&para;</a></h2>
<p>The <strong>Splitter</strong> component implements the main functionality of this library. This component is designed to deliver classes (inherited from <a href="#basesplitter"><strong><code>BaseSplitter</code></strong></a>) which supports to split a markdown text or a string following many different strategies. </p>
<h3 id="splitter-strategies-description">Splitter strategies description<a class="headerlink" href="#splitter-strategies-description" title="Permanent link">&para;</a></h3>
<table>
<thead>
<tr>
<th>Splitting Technique</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#charactersplitter"><strong>Character Splitter</strong></a></td>
<td>Splits text into chunks based on a specified number of characters. Supports overlapping by character count or percentage. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max chars per chunk), <code>chunk_overlap</code> (overlapping chars: int or %). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#wordsplitter"><strong>Word Splitter</strong> </a></td>
<td>Splits text into chunks based on a specified number of words. Supports overlapping by word count or percentage. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max words per chunk), <code>chunk_overlap</code> (overlapping words: int or %). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#sentencesplitter"><strong>Sentence Splitter</strong></a></td>
<td>Splits text into chunks by a specified number of sentences. Allows overlap defined by a number or percentage of words from the end of the previous chunk. Customizable sentence separators (e.g., <code>.</code>, <code>!</code>, <code>?</code>). <br> <strong>Parameters:</strong> <code>chunk_size</code> (max sentences per chunk), <code>chunk_overlap</code> (overlapping words: int or %), <code>sentence_separators</code> (list of characters). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#paragraphsplitter"><strong>Paragraph Splitter</strong></a></td>
<td>Splits text into chunks based on a specified number of paragraphs. Allows overlapping by word count or percentage, and customizable line breaks. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max paragraphs per chunk), <code>chunk_overlap</code> (overlapping words: int or %), <code>line_break</code> (delimiter(s) for paragraphs). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#recursivesplitter"><strong>Recursive Splitter</strong></a></td>
<td>Recursively splits text based on a hierarchy of separators (e.g., paragraph, sentence, word, character) until chunks reach a target size. Tries to preserve semantic units as long as possible. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max chars per chunk), <code>chunk_overlap</code> (overlapping chars), <code>separators</code> (list of characters to split on, e.g., <code>["\n\n", "\n", " ", ""]</code>). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#keywordsplitter"><strong>Keyword Splitter</strong></a></td>
<td>Splits text into chunks around matches of specified keywords, using one or more regex patterns. Supports precise boundary controlmatched keywords can be included <code>before</code>, <code>after</code>, <code>both</code> sides, or omitted from the split. Each keyword can have a custom name (via <code>dict</code>) for metadata counting. Secondary soft-wrapping by <code>chunk_size</code> is supported. <br> <strong>Parameters:</strong> <code>patterns</code> (list of regex patterns, or <code>dict</code> mapping names to patterns), <code>include_delimiters</code> (<code>"before"</code>, <code>"after"</code>, <code>"both"</code>, or <code>"none"</code>), <code>flags</code> (regex flags, e.g. <code>re.MULTILINE</code>), <code>chunk_size</code> (max chars per chunk, soft-wrapped). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#tokensplitter"><strong>Token Splitter</strong></a></td>
<td>Splits text into chunks based on the number of tokens, using various tokenization models (e.g., tiktoken, spaCy, NLTK). Useful for ensuring chunks are compatible with LLM context limits. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max tokens per chunk), <code>model_name</code> (tokenizer/model, e.g., <code>"tiktoken/cl100k_base"</code>, <code>"spacy/en_core_web_sm"</code>, <code>"nltk/punkt"</code>), <code>language</code> (for NLTK). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#pagedsplitter"><strong>Paged Splitter</strong></a></td>
<td>Splits text by pages for documents that have page structure. Each chunk contains a specified number of pages, with optional word overlap. <br> <strong>Parameters:</strong> <code>num_pages</code> (pages per chunk), <code>chunk_overlap</code> (overlapping words). <br> <strong>Compatible with:</strong> Word, PDF, Excel, PowerPoint.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#rowcolumnsplitter"><strong>Row/Column Splitter</strong></a></td>
<td>For tabular formats, splits data by a set number of rows or columns per chunk, with possible overlap. Row-based and column-based splitting are mutually exclusive. <br> <strong>Parameters:</strong> <code>num_rows</code>, <code>num_cols</code> (rows/columns per chunk), <code>overlap</code> (overlapping rows or columns). <br> <strong>Compatible with:</strong> Tabular formats (csv, tsv, parquet, flat json).</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#recursivejsonsplitter"><strong>JSON Splitter</strong></a></td>
<td>Recursively splits JSON documents into smaller sub-structures that preserve the original JSON schema. <br> <strong>Parameters:</strong> <code>max_chunk_size</code> (max chars per chunk), <code>min_chunk_size</code> (min chars per chunk). <br> <strong>Compatible with:</strong> JSON.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#semanticsplitter"><strong>Semantic Splitter</strong></a></td>
<td>Splits text into chunks based on semantic similarity, using an embedding model and a max tokens parameter. Useful for meaningful semantic groupings. <br> <strong>Parameters:</strong> <code>embedding_model</code> (model for embeddings), <code>max_tokens</code> (max tokens per chunk). <br> <strong>Compatible with:</strong> Text.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#htmltagsplitter"><strong>HTML Tag Splitter</strong></a></td>
<td>Splits HTML content based on a specified tag, or automatically detects the most frequent and shallowest tag if not specified. Each chunk is a complete HTML fragment for that tag. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max chars per chunk), <code>tag</code> (HTML tag to split on, optional). <br> <strong>Compatible with:</strong> HTML.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#headersplitter"><strong>Header Splitter</strong></a></td>
<td>Splits Markdown or HTML documents into chunks using header levels (e.g., <code>#</code>, <code>##</code>, or <code>&lt;h1&gt;</code>, <code>&lt;h2&gt;</code>). Uses configurable headers for chunking. <br> <strong>Parameters:</strong> <code>headers_to_split_on</code> (list of headers and semantic names), <code>chunk_size</code> (unused, for compatibility). <br> <strong>Compatible with:</strong> Markdown, HTML.</td>
</tr>
<tr>
<td><a href="https://andreshere00.github.io/Splitter_MR/api_reference/splitter/#codesplitter"><strong>Code Splitter</strong></a></td>
<td>Splits source code files into programmatically meaningful chunks (functions, classes, methods, etc.), aware of the syntax of the specified programming language (e.g., Python, Java, Kotlin). Uses language-aware logic to avoid splitting inside code blocks. <br> <strong>Parameters:</strong> <code>chunk_size</code> (max chars per chunk), <code>language</code> (programming language as string, e.g., <code>"python"</code>, <code>"java"</code>). <br> <strong>Compatible with:</strong> Source code files (Python, Java, Kotlin, C++, JavaScript, Go, etc.).</td>
</tr>
</tbody>
</table>
<h3 id="output-format">Output format<a class="headerlink" href="#output-format" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-class">



<a id="splitter_mr.schema.models.SplitterOutput"></a>
    <div class="doc doc-contents first">
            <p class="doc doc-class-bases">
              Bases: <code><span title="pydantic.BaseModel">BaseModel</span></code></p>


        <p>Pydantic model defining the output structure for all splitters.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.chunks">chunks</span></code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of text chunks produced by splitting.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.chunk_id">chunk_id</span></code></td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>List of unique IDs corresponding to each chunk.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.document_name">document_name</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The name of the document.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.document_path">document_path</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The path to the document.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.document_id">document_id</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A unique identifier for the document.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.conversion_method">conversion_method</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used for document conversion.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.reader_method">reader_method</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used for reading the document.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.ocr_method">ocr_method</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The OCR method used, if any.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.split_method">split_method</span></code></td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The method used to split the document.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.split_params">split_params</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Parameters used during the splitting process.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.schema.models.SplitterOutput.metadata">metadata</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Additional metadata associated with the splitting.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/schema/models.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SplitterOutput</span><span class="p">(</span><span class="n">BaseModel</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Pydantic model defining the output structure for all splitters.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        chunks: List of text chunks produced by splitting.</span>
<span class="sd">        chunk_id: List of unique IDs corresponding to each chunk.</span>
<span class="sd">        document_name: The name of the document.</span>
<span class="sd">        document_path: The path to the document.</span>
<span class="sd">        document_id: A unique identifier for the document.</span>
<span class="sd">        conversion_method: The method used for document conversion.</span>
<span class="sd">        reader_method: The method used for reading the document.</span>
<span class="sd">        ocr_method: The OCR method used, if any.</span>
<span class="sd">        split_method: The method used to split the document.</span>
<span class="sd">        split_params: Parameters used during the splitting process.</span>
<span class="sd">        metadata: Additional metadata associated with the splitting.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">chunk_id</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">list</span><span class="p">)</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">document_id</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">conversion_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">reader_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">ocr_method</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="n">split_method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="n">split_params</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>
    <span class="n">metadata</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]</span> <span class="o">=</span> <span class="n">Field</span><span class="p">(</span><span class="n">default_factory</span><span class="o">=</span><span class="nb">dict</span><span class="p">)</span>

    <span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">validate_and_set_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Validates and sets defaults for the SplitterOutput instance.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `chunks` is empty or if `chunk_id` length does not match `chunks` length.</span>

<span class="sd">        Returns:</span>
<span class="sd">            self (SplitterOutput): The validated and updated instance.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chunks list cannot be empty.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;chunk_id length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match chunks length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">document_id</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">document_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_chunks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;SplitterOutput&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a SplitterOutput from a list of chunks, with all other fields set to their defaults.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunks (List[str]): A list of text chunks.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: An instance of SplitterOutput with the given chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">append_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Append (update) the metadata dictionary with new key-value pairs.</span>

<span class="sd">        Args:</span>
<span class="sd">            metadata (Dict[str, Any]): The metadata to add or update.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h5 id="splitter_mr.schema.models.SplitterOutput.validate_and_set_defaults" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">validate_and_set_defaults</span><span class="p">()</span></code>

<a href="#splitter_mr.schema.models.SplitterOutput.validate_and_set_defaults" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">

        <p>Validates and sets defaults for the SplitterOutput instance.</p>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If <code>chunks</code> is empty or if <code>chunk_id</code> length does not match <code>chunks</code> length.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>self</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.models.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The validated and updated instance.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/schema/models.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@model_validator</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;after&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">validate_and_set_defaults</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Validates and sets defaults for the SplitterOutput instance.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `chunks` is empty or if `chunk_id` length does not match `chunks` length.</span>

<span class="sd">    Returns:</span>
<span class="sd">        self (SplitterOutput): The validated and updated instance.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Chunks list cannot be empty.&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;chunk_id length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span><span class="p">)</span><span class="si">}</span><span class="s2">) does not match chunks length (</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span><span class="si">}</span><span class="s2">).&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_id</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunks</span><span class="p">]</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">document_id</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">document_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

    <span class="k">return</span> <span class="bp">self</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h5 id="splitter_mr.schema.models.SplitterOutput.from_chunks" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">from_chunks</span><span class="p">(</span><span class="n">chunks</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-classmethod"><code>classmethod</code></small>
  </span>

<a href="#splitter_mr.schema.models.SplitterOutput.from_chunks" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">

        <p>Create a SplitterOutput from a list of chunks, with all other fields set to their defaults.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunks</code>
            </td>
            <td>
                  <code><span title="typing.List">List</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of text chunks.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.models.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>An instance of SplitterOutput with the given chunks.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/schema/models.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@classmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">from_chunks</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="s2">&quot;SplitterOutput&quot;</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a SplitterOutput from a list of chunks, with all other fields set to their defaults.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunks (List[str]): A list of text chunks.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: An instance of SplitterOutput with the given chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h5 id="splitter_mr.schema.models.SplitterOutput.append_metadata" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">append_metadata</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span></code>

<a href="#splitter_mr.schema.models.SplitterOutput.append_metadata" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">

        <p>Append (update) the metadata dictionary with new key-value pairs.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>metadata</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The metadata to add or update.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/schema/models.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">append_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">metadata</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append (update) the metadata dictionary with new key-value pairs.</span>

<span class="sd">    Args:</span>
<span class="sd">        metadata (Dict[str, Any]): The metadata to add or update.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">metadata</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">metadata</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h2 id="splitters">Splitters<a class="headerlink" href="#splitters" title="Permanent link">&para;</a></h2>
<h3 id="basesplitter">BaseSplitter<a class="headerlink" href="#basesplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.base_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.base_splitter.BaseSplitter" class="doc doc-heading">
            <code>BaseSplitter</code>


<a href="#splitter_mr.splitter.base_splitter.BaseSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><span title="abc.ABC">ABC</span></code></p>


        <p>Abstract base class for all splitter implementations.</p>
<p>This class defines the common interface and utility methods for splitters that
divide text or data into smaller chunks, typically for downstream natural language
processing tasks or information retrieval. Subclasses should implement the <code>split</code>
method, which takes in a dictionary (typically from a document reader) and returns
a structured output with the required chunking.</p>


<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.splitter.base_splitter.BaseSplitter.chunk_size">chunk_size</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The maximum number of units (e.g., characters, words, etc.) per chunk.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Methods:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
            <tr class="doc-section-item">
              <td><code><a class="autorefs autorefs-internal" title="split(reader_output)

  
      abstractmethod
   (splitter_mr.splitter.base_splitter.BaseSplitter.split)" href="#splitter_mr.splitter.base_splitter.BaseSplitter.split">split</a></code></td>
              <td>
                <div class="doc-md-description">
                  <p>Abstract method. Should be implemented by all subclasses to perform the actual
splitting logic.</p>
                </div>
              </td>
            </tr>
            <tr class="doc-section-item">
              <td><code><span title="splitter_mr.splitter.base_splitter.BaseSplitter._generate_chunk_ids">_generate_chunk_ids</span></code></td>
              <td>
                <div class="doc-md-description">
                  <p>Generates a list of unique chunk IDs using UUID4, for use in the output.</p>
                </div>
              </td>
            </tr>
            <tr class="doc-section-item">
              <td><code><span title="splitter_mr.splitter.base_splitter.BaseSplitter._default_metadata">_default_metadata</span></code></td>
              <td>
                <div class="doc-md-description">
                  <p>Returns a default (empty) metadata dictionary, which can be extended by subclasses.</p>
                </div>
              </td>
            </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/base_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BaseSplitter</span><span class="p">(</span><span class="n">ABC</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract base class for all splitter implementations.</span>

<span class="sd">    This class defines the common interface and utility methods for splitters that</span>
<span class="sd">    divide text or data into smaller chunks, typically for downstream natural language</span>
<span class="sd">    processing tasks or information retrieval. Subclasses should implement the `split`</span>
<span class="sd">    method, which takes in a dictionary (typically from a document reader) and returns</span>
<span class="sd">    a structured output with the required chunking.</span>

<span class="sd">    Attributes:</span>
<span class="sd">        chunk_size (int): The maximum number of units (e.g., characters, words, etc.) per chunk.</span>

<span class="sd">    Methods:</span>
<span class="sd">        split: Abstract method. Should be implemented by all subclasses to perform the actual</span>
<span class="sd">            splitting logic.</span>

<span class="sd">        _generate_chunk_ids: Generates a list of unique chunk IDs using UUID4, for use in the output.</span>

<span class="sd">        _default_metadata: Returns a default (empty) metadata dictionary, which can be extended by subclasses.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializer method for BaseSplitter classes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>

    <span class="nd">@abstractmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Abstract method to split input data into chunks.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): Input data, typically from a document reader,</span>
<span class="sd">                including the text to split and any relevant metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: A dictionary containing split chunks and associated metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_generate_chunk_ids</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_chunks</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generate a list of unique chunk identifiers.</span>

<span class="sd">        Args:</span>
<span class="sd">            num_chunks (int): Number of chunk IDs to generate.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[str]: List of unique string IDs (UUID4).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_chunks</span><span class="p">)]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_default_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">dict</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return a default metadata dictionary.</span>

<span class="sd">        Returns:</span>
<span class="sd">            dict: An empty dictionary; subclasses may override to provide additional metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.base_splitter.BaseSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.base_splitter.BaseSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Initializer method for BaseSplitter classes</p>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/base_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initializer method for BaseSplitter classes</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.base_splitter.BaseSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-abstractmethod"><code>abstractmethod</code></small>
  </span>

<a href="#splitter_mr.splitter.base_splitter.BaseSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Abstract method to split input data into chunks.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input data, typically from a document reader,
including the text to split and any relevant metadata.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A dictionary containing split chunks and associated metadata.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/base_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@abstractmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Abstract method to split input data into chunks.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (ReaderOutput): Input data, typically from a document reader,</span>
<span class="sd">            including the text to split and any relevant metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: A dictionary containing split chunks and associated metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="charactersplitter">CharacterSplitter<a class="headerlink" href="#charactersplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.character_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.character_splitter.CharacterSplitter" class="doc doc-heading">
            <code>CharacterSplitter</code>


<a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>CharacterSplitter splits a given text into overlapping or non-overlapping chunks
based on a specified number of characters per chunk.</p>
<p>This splitter is configurable with a maximum chunk size (<code>chunk_size</code>) and an overlap
between consecutive chunks (<code>chunk_overlap</code>). The overlap can be specified either as
an integer (number of characters) or as a float between 0 and 1 (fraction of chunk size).
This is particularly useful for downstream NLP tasks where context preservation between
chunks is important.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of characters per chunk.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number or percentage of overlapping characters
between chunks.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/character_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  5</span>
<span class="normal">  6</span>
<span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CharacterSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CharacterSplitter splits a given text into overlapping or non-overlapping chunks</span>
<span class="sd">    based on a specified number of characters per chunk.</span>

<span class="sd">    This splitter is configurable with a maximum chunk size (`chunk_size`) and an overlap</span>
<span class="sd">    between consecutive chunks (`chunk_overlap`). The overlap can be specified either as</span>
<span class="sd">    an integer (number of characters) or as a float between 0 and 1 (fraction of chunk size).</span>
<span class="sd">    This is particularly useful for downstream NLP tasks where context preservation between</span>
<span class="sd">    chunks is important.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of characters per chunk.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number or percentage of overlapping characters</span>
<span class="sd">            between chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text from the reader_output dictionary into character-based chunks.</span>

<span class="sd">        Each chunk contains at most `chunk_size` characters, and adjacent chunks can overlap</span>
<span class="sd">        by a specified number or percentage of characters, according to the `chunk_overlap`</span>
<span class="sd">        parameter set at initialization. Returns a dictionary with the same document metadata,</span>
<span class="sd">        unique chunk identifiers, and the split parameters used.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">                (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If chunk_overlap is greater than or equal to chunk_size.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import CharacterSplitter</span>

<span class="sd">            # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;abcdefghijklmnopqrstuvwxyz&quot;,</span>
<span class="sd">                document_name: &quot;doc.txt&quot;,</span>
<span class="sd">                document_path: &quot;/path/doc.txt&quot;,</span>
<span class="sd">            )</span>
<span class="sd">            splitter = CharacterSplitter(chunk_size=5, chunk_overlap=2)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;abcde&#39;, &#39;defgh&#39;, &#39;ghijk&#39;, ..., &#39;yz&#39;]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Determine overlap in characters</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

        <span class="c1"># Split into chunks</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;character_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.character_splitter.CharacterSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.character_splitter.CharacterSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text from the reader_output dictionary into character-based chunks.</p>
<p>Each chunk contains at most <code>chunk_size</code> characters, and adjacent chunks can overlap
by a specified number or percentage of characters, according to the <code>chunk_overlap</code>
parameter set at initialization. Returns a dictionary with the same document metadata,
unique chunk identifiers, and the split parameters used.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str) and optional document metadata
(e.g., 'document_name', 'document_path', etc.).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If chunk_overlap is greater than or equal to chunk_size.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">CharacterSplitter</span>

<span class="c1"># This dictionary has been obtained as the output from a Reader object.</span>
<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;abcdefghijklmnopqrstuvwxyz&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;doc.txt&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/path/doc.txt&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">CharacterSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;abcde&#39;</span><span class="p">,</span> <span class="s1">&#39;defgh&#39;</span><span class="p">,</span> <span class="s1">&#39;ghijk&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="s1">&#39;yz&#39;</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/character_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text from the reader_output dictionary into character-based chunks.</span>

<span class="sd">    Each chunk contains at most `chunk_size` characters, and adjacent chunks can overlap</span>
<span class="sd">    by a specified number or percentage of characters, according to the `chunk_overlap`</span>
<span class="sd">    parameter set at initialization. Returns a dictionary with the same document metadata,</span>
<span class="sd">    unique chunk identifiers, and the split parameters used.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">            (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If chunk_overlap is greater than or equal to chunk_size.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import CharacterSplitter</span>

<span class="sd">        # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;abcdefghijklmnopqrstuvwxyz&quot;,</span>
<span class="sd">            document_name: &quot;doc.txt&quot;,</span>
<span class="sd">            document_path: &quot;/path/doc.txt&quot;,</span>
<span class="sd">        )</span>
<span class="sd">        splitter = CharacterSplitter(chunk_size=5, chunk_overlap=2)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;abcde&#39;, &#39;defgh&#39;, &#39;ghijk&#39;, ..., &#39;yz&#39;]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Determine overlap in characters</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

    <span class="c1"># Split into chunks</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">])</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;character_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="wordsplitter">WordSplitter<a class="headerlink" href="#wordsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.word_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.word_splitter.WordSplitter" class="doc doc-heading">
            <code>WordSplitter</code>


<a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>WordSplitter splits a given text into overlapping or non-overlapping chunks
based on a specified number of words per chunk.</p>
<p>This splitter is configurable with a maximum chunk size (<code>chunk_size</code>, in words)
and an overlap between consecutive chunks (<code>chunk_overlap</code>). The overlap can be
specified either as an integer (number of words) or as a float between 0 and 1
(fraction of chunk size). Useful for NLP tasks where word-based boundaries are
important for context preservation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of words per chunk.</p>
              </div>
            </td>
            <td>
                  <code>5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number or percentage of overlapping words between chunks.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/word_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WordSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    WordSplitter splits a given text into overlapping or non-overlapping chunks</span>
<span class="sd">    based on a specified number of words per chunk.</span>

<span class="sd">    This splitter is configurable with a maximum chunk size (`chunk_size`, in words)</span>
<span class="sd">    and an overlap between consecutive chunks (`chunk_overlap`). The overlap can be</span>
<span class="sd">    specified either as an integer (number of words) or as a float between 0 and 1</span>
<span class="sd">    (fraction of chunk size). Useful for NLP tasks where word-based boundaries are</span>
<span class="sd">    important for context preservation.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of words per chunk.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number or percentage of overlapping words between chunks.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text from the reader_output dictionary into word-based chunks.</span>

<span class="sd">        Each chunk contains at most `chunk_size` words, and adjacent chunks can overlap</span>
<span class="sd">        by a specified number or percentage of words, according to the `chunk_overlap`</span>
<span class="sd">        parameter set at initialization.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">                (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If chunk_overlap is greater than or equal to chunk_size.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import WordSplitter</span>

<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs. Sphinx of black quartz, judge my vow.&quot;,</span>
<span class="sd">                document_name: &quot;pangrams.txt&quot;,</span>
<span class="sd">                document_path: &quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/pangrams.txt&quot;,</span>
<span class="sd">            )</span>

<span class="sd">            # Split into chunks of 5 words, overlapping by 2 words</span>
<span class="sd">            splitter = WordSplitter(chunk_size=5, chunk_overlap=2)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;The quick brown fox jumps&#39;,</span>
<span class="sd">            &#39;fox jumps over the lazy&#39;,</span>
<span class="sd">            &#39;over the lazy dog. Pack&#39;, ...]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Split text into words (using simple whitespace tokenization)</span>
        <span class="n">words</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
        <span class="n">total_words</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

        <span class="c1"># Determine overlap in characters</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

        <span class="c1"># Split into chunks</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">step</span> <span class="o">=</span> <span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">total_words</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
            <span class="n">chunk_words</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_words</span><span class="p">))</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">step</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;word_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.word_splitter.WordSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.word_splitter.WordSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text from the reader_output dictionary into word-based chunks.</p>
<p>Each chunk contains at most <code>chunk_size</code> words, and adjacent chunks can overlap
by a specified number or percentage of words, according to the <code>chunk_overlap</code>
parameter set at initialization.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str) and optional document metadata
(e.g., 'document_name', 'document_path', etc.).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If chunk_overlap is greater than or equal to chunk_size.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">WordSplitter</span>

<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs. Sphinx of black quartz, judge my vow.&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;pangrams.txt&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/pangrams.txt&quot;</span><span class="p">,</span>
<span class="p">)</span>

<span class="c1"># Split into chunks of 5 words, overlapping by 2 words</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">WordSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;The quick brown fox jumps&#39;</span><span class="p">,</span>
<span class="s1">&#39;fox jumps over the lazy&#39;</span><span class="p">,</span>
<span class="s1">&#39;over the lazy dog. Pack&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/word_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text from the reader_output dictionary into word-based chunks.</span>

<span class="sd">    Each chunk contains at most `chunk_size` words, and adjacent chunks can overlap</span>
<span class="sd">    by a specified number or percentage of words, according to the `chunk_overlap`</span>
<span class="sd">    parameter set at initialization.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">            (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If chunk_overlap is greater than or equal to chunk_size.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import WordSplitter</span>

<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;The quick brown fox jumps over the lazy dog. Pack my box with five dozen liquor jugs. Sphinx of black quartz, judge my vow.&quot;,</span>
<span class="sd">            document_name: &quot;pangrams.txt&quot;,</span>
<span class="sd">            document_path: &quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/pangrams.txt&quot;,</span>
<span class="sd">        )</span>

<span class="sd">        # Split into chunks of 5 words, overlapping by 2 words</span>
<span class="sd">        splitter = WordSplitter(chunk_size=5, chunk_overlap=2)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;The quick brown fox jumps&#39;,</span>
<span class="sd">        &#39;fox jumps over the lazy&#39;,</span>
<span class="sd">        &#39;over the lazy dog. Pack&#39;, ...]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Split text into words (using simple whitespace tokenization)</span>
    <span class="n">words</span> <span class="o">=</span> <span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
    <span class="n">total_words</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">words</span><span class="p">)</span>

    <span class="c1"># Determine overlap in characters</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

    <span class="c1"># Split into chunks</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">step</span> <span class="o">=</span> <span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">total_words</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span>
        <span class="n">chunk_words</span> <span class="o">=</span> <span class="n">words</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_words</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">step</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;word_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="sentencesplitter">SentenceSplitter<a class="headerlink" href="#sentencesplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.sentence_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter" class="doc doc-heading">
            <code>SentenceSplitter</code>


<a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>SentenceSplitter splits a given text into overlapping or non-overlapping chunks,
where each chunk contains a specified number of sentences, and overlap is defined
by a number or percentage of words from the end of the previous chunk.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of sentences per chunk.</p>
              </div>
            </td>
            <td>
                  <code>5</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number or percentage of overlapping words between chunks.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>separators</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Character(s) to split sentences.</p>
              </div>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.DEFAULT_SENTENCE_SEPARATORS">DEFAULT_SENTENCE_SEPARATORS</span></code>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/sentence_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SentenceSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    SentenceSplitter splits a given text into overlapping or non-overlapping chunks,</span>
<span class="sd">    where each chunk contains a specified number of sentences, and overlap is defined</span>
<span class="sd">    by a number or percentage of words from the end of the previous chunk.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of sentences per chunk.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number or percentage of overlapping words between chunks.</span>
<span class="sd">        separators (Union[str, List[str]]): Character(s) to split sentences.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">separators</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">DEFAULT_SENTENCE_SEPARATORS</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">separators</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="c1"># Legacy path (NOT recommended): join list with alternation, ensure &quot;...&quot; before &quot;.&quot;</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">({</span><span class="o">*</span><span class="n">separators</span><span class="p">},</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="p">(</span><span class="n">s</span> <span class="o">!=</span> <span class="s2">&quot;...&quot;</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
            <span class="n">sep_pattern</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">parts</span><span class="p">)</span>
            <span class="c1"># Attach trailing quotes/brackets if user insisted on a list</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">separators</span> <span class="o">=</span> <span class="sa">rf</span><span class="s1">&#39;(?:</span><span class="si">{</span><span class="n">sep_pattern</span><span class="si">}</span><span class="s1">)(?:[&quot;</span><span class="se">\&#39;</span><span class="s1">\)\]\</span><span class="se">}}</span><span class="s1">]*)\s*&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Recommended path: already a full regex pattern</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">separators</span> <span class="o">=</span> <span class="n">separators</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_sep_re</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="si">}</span><span class="s2">)&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text from the `reader_output` dictionary into sentence-based chunks,</span>
<span class="sd">        allowing for overlap at the word level.</span>

<span class="sd">        Each chunk contains at most `chunk_size` sentences, where sentence boundaries are</span>
<span class="sd">        detected using the specified `separators` (e.g., &#39;.&#39;, &#39;!&#39;, &#39;?&#39;).</span>
<span class="sd">        Overlap between consecutive chunks is specified by `chunk_overlap`, which can be an</span>
<span class="sd">        integer (number of words) or a float (fraction of the maximum words in a sentence).</span>
<span class="sd">        This is useful for downstream NLP tasks that require context preservation.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata,</span>
<span class="sd">                such as &#39;document_name&#39;, &#39;document_path&#39;, &#39;document_id&#39;, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If `chunk_overlap` is negative.</span>
<span class="sd">            ValueError: If &#39;text&#39; is missing in `reader_output`.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import SentenceSplitter</span>

<span class="sd">            # Example input: 7 sentences with varied punctuation</span>
<span class="sd">            # This dictionary has been obtained as an output from a Reader class.</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;Hello world! How are you? I am fine. Testing sentence splitting. Short. End! And another?&quot;,</span>
<span class="sd">                document_name: &quot;sample.txt&quot;,</span>
<span class="sd">                document_path: &quot;/tmp/sample.txt&quot;,</span>
<span class="sd">                document_id: &quot;123&quot;</span>
<span class="sd">            )</span>

<span class="sd">            # Split into chunks of 3 sentences each, no overlap</span>
<span class="sd">            splitter = SentenceSplitter(chunk_size=3, chunk_overlap=0)</span>
<span class="sd">            result = splitter.split(reader_output)</span>
<span class="sd">            print(result.chunks)</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;Hello world! How are you? I am fine.&#39;,</span>
<span class="sd">             &#39;Testing sentence splitting. Short. End!&#39;,</span>
<span class="sd">             &#39;And another?&#39;, ...]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Build sentence list</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="n">merged_sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># [text, sep, text, sep, ...]</span>
            <span class="n">merged_sentences</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
                <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                    <span class="n">parts</span>
                <span class="p">):</span>  <span class="c1"># we have a separator that belongs to this sentence</span>
                    <span class="n">sep</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
                    <span class="n">sentence</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span> <span class="o">+</span> <span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
                        <span class="n">merged_sentences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># tail without terminator</span>
                    <span class="k">if</span> <span class="n">segment</span><span class="p">:</span>
                        <span class="n">merged_sentences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">merged_sentences</span><span class="p">:</span>
                <span class="n">merged_sentences</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="n">num_sentences</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_sentences</span><span class="p">)</span>

        <span class="c1"># Determine overlap in words</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">max_sent_words</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">merged_sentences</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_sent_words</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be &gt;= 0&quot;</span><span class="p">)</span>

        <span class="c1"># Build chunks of up to `chunk_size` sentences (single implementation, no duplication)</span>
        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">num_sentences</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">num_sentences</span><span class="p">)</span>
            <span class="n">chunk_sents</span> <span class="o">=</span> <span class="n">merged_sentences</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">chunk_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_sents</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
                <span class="n">prev_words</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">overlap_words</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">prev_words</span><span class="p">[</span><span class="o">-</span><span class="n">overlap</span><span class="p">:]</span> <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_words</span><span class="p">)</span> <span class="k">else</span> <span class="n">prev_words</span>
                <span class="p">)</span>
                <span class="n">chunk_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">overlap_words</span><span class="p">),</span> <span class="n">chunk_text</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="n">chunk_size</span>

        <span class="c1"># Generate chunk_id and append metadata, then return once</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;sentence_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
                <span class="s2">&quot;separators&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.sentence_splitter.SentenceSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text from the <code>reader_output</code> dictionary into sentence-based chunks,
allowing for overlap at the word level.</p>
<p>Each chunk contains at most <code>chunk_size</code> sentences, where sentence boundaries are
detected using the specified <code>separators</code> (e.g., '.', '!', '?').
Overlap between consecutive chunks is specified by <code>chunk_overlap</code>, which can be an
integer (number of words) or a float (fraction of the maximum words in a sentence).
This is useful for downstream NLP tasks that require context preservation.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str) and optional document metadata,
such as 'document_name', 'document_path', 'document_id', etc.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If <code>chunk_overlap</code> is negative.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If 'text' is missing in <code>reader_output</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">SentenceSplitter</span>

<span class="c1"># Example input: 7 sentences with varied punctuation</span>
<span class="c1"># This dictionary has been obtained as an output from a Reader class.</span>
<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;Hello world! How are you? I am fine. Testing sentence splitting. Short. End! And another?&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;sample.txt&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/tmp/sample.txt&quot;</span><span class="p">,</span>
    <span class="n">document_id</span><span class="p">:</span> <span class="s2">&quot;123&quot;</span>
<span class="p">)</span>

<span class="c1"># Split into chunks of 3 sentences each, no overlap</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">SentenceSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">result</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">result</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;Hello world! How are you? I am fine.&#39;</span><span class="p">,</span>
 <span class="s1">&#39;Testing sentence splitting. Short. End!&#39;</span><span class="p">,</span>
 <span class="s1">&#39;And another?&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/sentence_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text from the `reader_output` dictionary into sentence-based chunks,</span>
<span class="sd">    allowing for overlap at the word level.</span>

<span class="sd">    Each chunk contains at most `chunk_size` sentences, where sentence boundaries are</span>
<span class="sd">    detected using the specified `separators` (e.g., &#39;.&#39;, &#39;!&#39;, &#39;?&#39;).</span>
<span class="sd">    Overlap between consecutive chunks is specified by `chunk_overlap`, which can be an</span>
<span class="sd">    integer (number of words) or a float (fraction of the maximum words in a sentence).</span>
<span class="sd">    This is useful for downstream NLP tasks that require context preservation.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata,</span>
<span class="sd">            such as &#39;document_name&#39;, &#39;document_path&#39;, &#39;document_id&#39;, etc.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If `chunk_overlap` is negative.</span>
<span class="sd">        ValueError: If &#39;text&#39; is missing in `reader_output`.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import SentenceSplitter</span>

<span class="sd">        # Example input: 7 sentences with varied punctuation</span>
<span class="sd">        # This dictionary has been obtained as an output from a Reader class.</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;Hello world! How are you? I am fine. Testing sentence splitting. Short. End! And another?&quot;,</span>
<span class="sd">            document_name: &quot;sample.txt&quot;,</span>
<span class="sd">            document_path: &quot;/tmp/sample.txt&quot;,</span>
<span class="sd">            document_id: &quot;123&quot;</span>
<span class="sd">        )</span>

<span class="sd">        # Split into chunks of 3 sentences each, no overlap</span>
<span class="sd">        splitter = SentenceSplitter(chunk_size=3, chunk_overlap=0)</span>
<span class="sd">        result = splitter.split(reader_output)</span>
<span class="sd">        print(result.chunks)</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;Hello world! How are you? I am fine.&#39;,</span>
<span class="sd">         &#39;Testing sentence splitting. Short. End!&#39;,</span>
<span class="sd">         &#39;And another?&#39;, ...]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Build sentence list</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
        <span class="n">merged_sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">parts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sep_re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>  <span class="c1"># [text, sep, text, sep, ...]</span>
        <span class="n">merged_sentences</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">parts</span><span class="p">):</span>
            <span class="n">segment</span> <span class="o">=</span> <span class="p">(</span><span class="n">parts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span>
                <span class="n">parts</span>
            <span class="p">):</span>  <span class="c1"># we have a separator that belongs to this sentence</span>
                <span class="n">sep</span> <span class="o">=</span> <span class="n">parts</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
                <span class="n">sentence</span> <span class="o">=</span> <span class="p">(</span><span class="n">segment</span> <span class="o">+</span> <span class="n">sep</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">sentence</span><span class="p">:</span>
                    <span class="n">merged_sentences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sentence</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># tail without terminator</span>
                <span class="k">if</span> <span class="n">segment</span><span class="p">:</span>
                    <span class="n">merged_sentences</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">segment</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">merged_sentences</span><span class="p">:</span>
            <span class="n">merged_sentences</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

    <span class="n">num_sentences</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">merged_sentences</span><span class="p">)</span>

    <span class="c1"># Determine overlap in words</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">max_sent_words</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">merged_sentences</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_sent_words</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be &gt;= 0&quot;</span><span class="p">)</span>

    <span class="c1"># Build chunks of up to `chunk_size` sentences (single implementation, no duplication)</span>
    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">num_sentences</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="n">num_sentences</span><span class="p">)</span>
        <span class="n">chunk_sents</span> <span class="o">=</span> <span class="n">merged_sentences</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">chunk_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_sents</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="n">prev_words</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">overlap_words</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">prev_words</span><span class="p">[</span><span class="o">-</span><span class="n">overlap</span><span class="p">:]</span> <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_words</span><span class="p">)</span> <span class="k">else</span> <span class="n">prev_words</span>
            <span class="p">)</span>
            <span class="n">chunk_text</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">overlap_words</span><span class="p">),</span> <span class="n">chunk_text</span><span class="p">])</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_text</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="n">chunk_size</span>

    <span class="c1"># Generate chunk_id and append metadata, then return once</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;sentence_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="s2">&quot;separators&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="paragraphsplitter">ParagraphSplitter<a class="headerlink" href="#paragraphsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.paragraph_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter" class="doc doc-heading">
            <code>ParagraphSplitter</code>


<a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>ParagraphSplitter splits a given text into overlapping or non-overlapping chunks,
where each chunk contains a specified number of paragraphs, and overlap is defined
by a number or percentage of words from the end of the previous chunk.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of paragraphs per chunk.</p>
              </div>
            </td>
            <td>
                  <code>3</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number or percentage of overlapping words between chunks.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>line_break</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Character(s) used to split text into paragraphs.</p>
              </div>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.DEFAULT_PARAGRAPH_SEPARATORS">DEFAULT_PARAGRAPH_SEPARATORS</span></code>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/paragraph_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">ParagraphSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    ParagraphSplitter splits a given text into overlapping or non-overlapping chunks,</span>
<span class="sd">    where each chunk contains a specified number of paragraphs, and overlap is defined</span>
<span class="sd">    by a number or percentage of words from the end of the previous chunk.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of paragraphs per chunk.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number or percentage of overlapping words between chunks.</span>
<span class="sd">        line_break (Union[str, List[str]]): Character(s) used to split text into paragraphs.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">line_break</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">DEFAULT_PARAGRAPH_SEPARATORS</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span> <span class="o">=</span> <span class="n">line_break</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">line_break</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">line_break</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits text in `reader_output[&#39;text&#39;]` into paragraph-based chunks, with optional word overlap.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]): Dictionary containing at least a &#39;text&#39; key (str)</span>
<span class="sd">                and optional document metadata (e.g., &#39;document_name&#39;, &#39;document_path&#39;).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If &#39;text&#39; is missing from `reader_output` or is not a string.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import ParagraphSplitter</span>

<span class="sd">            # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;Para 1.\\n\\nPara 2.\\n\\nPara 3.&quot;,</span>
<span class="sd">                document_name: &quot;test.txt&quot;,</span>
<span class="sd">                document_path: &quot;/tmp/test.txt&quot;</span>
<span class="sd">            )</span>
<span class="sd">            splitter = ParagraphSplitter(chunk_size=2, chunk_overlap=1, line_break=&quot;\\n\\n&quot;)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;Para 1.\\n\\nPara 2.&#39;, &#39;2. Para 3.&#39;]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Intialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">line_breaks_pattern</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">))</span>
        <span class="n">paragraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">line_breaks_pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
        <span class="n">num_paragraphs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">paragraphs</span><span class="p">)</span>

        <span class="c1"># Determine overlap in words</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">max_para_words</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paragraphs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_para_words</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>

        <span class="c1"># Split into chunks</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">num_paragraphs</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">num_paragraphs</span><span class="p">)</span>
            <span class="n">chunk_paragraphs</span> <span class="o">=</span> <span class="n">paragraphs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">chunk_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_paragraphs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
                <span class="n">prev_words</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                <span class="n">overlap_words</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">prev_words</span><span class="p">[</span><span class="o">-</span><span class="n">overlap</span><span class="p">:]</span> <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_words</span><span class="p">)</span> <span class="k">else</span> <span class="n">prev_words</span>
                <span class="p">)</span>
                <span class="n">chunk_text</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">overlap_words</span><span class="p">),</span> <span class="n">chunk_text</span><span class="p">])</span>
                    <span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_text</span><span class="p">)</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;paragraph_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
                <span class="s2">&quot;line_break&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.paragraph_splitter.ParagraphSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits text in <code>reader_output['text']</code> into paragraph-based chunks, with optional word overlap.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str)
and optional document metadata (e.g., 'document_name', 'document_path').</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If 'text' is missing from <code>reader_output</code> or is not a string.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">ParagraphSplitter</span>

<span class="c1"># This dictionary has been obtained as the output from a Reader object.</span>
<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;Para 1.</span><span class="se">\n\n</span><span class="s2">Para 2.</span><span class="se">\n\n</span><span class="s2">Para 3.&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;test.txt&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/tmp/test.txt&quot;</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">ParagraphSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">line_break</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;Para 1.</span><span class="se">\n\n</span><span class="s1">Para 2.&#39;</span><span class="p">,</span> <span class="s1">&#39;2. Para 3.&#39;</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/paragraph_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits text in `reader_output[&#39;text&#39;]` into paragraph-based chunks, with optional word overlap.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]): Dictionary containing at least a &#39;text&#39; key (str)</span>
<span class="sd">            and optional document metadata (e.g., &#39;document_name&#39;, &#39;document_path&#39;).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If &#39;text&#39; is missing from `reader_output` or is not a string.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import ParagraphSplitter</span>

<span class="sd">        # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;Para 1.\\n\\nPara 2.\\n\\nPara 3.&quot;,</span>
<span class="sd">            document_name: &quot;test.txt&quot;,</span>
<span class="sd">            document_path: &quot;/tmp/test.txt&quot;</span>
<span class="sd">        )</span>
<span class="sd">        splitter = ParagraphSplitter(chunk_size=2, chunk_overlap=1, line_break=&quot;\\n\\n&quot;)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;Para 1.\\n\\nPara 2.&#39;, &#39;2. Para 3.&#39;]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Intialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">line_breaks_pattern</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">escape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">))</span>
    <span class="n">paragraphs</span> <span class="o">=</span> <span class="p">[</span><span class="n">p</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">line_breaks_pattern</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>
    <span class="n">num_paragraphs</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">paragraphs</span><span class="p">)</span>

    <span class="c1"># Determine overlap in words</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">max_para_words</span> <span class="o">=</span> <span class="nb">max</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="o">.</span><span class="n">split</span><span class="p">())</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">paragraphs</span><span class="p">),</span> <span class="n">default</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">max_para_words</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>

    <span class="c1"># Split into chunks</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">while</span> <span class="n">start</span> <span class="o">&lt;</span> <span class="n">num_paragraphs</span><span class="p">:</span>
        <span class="n">end</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">start</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">num_paragraphs</span><span class="p">)</span>
        <span class="n">chunk_paragraphs</span> <span class="o">=</span> <span class="n">paragraphs</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
        <span class="n">chunk_text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">chunk_paragraphs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="n">prev_words</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="n">overlap_words</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">prev_words</span><span class="p">[</span><span class="o">-</span><span class="n">overlap</span><span class="p">:]</span> <span class="k">if</span> <span class="n">overlap</span> <span class="o">&lt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">prev_words</span><span class="p">)</span> <span class="k">else</span> <span class="n">prev_words</span>
            <span class="p">)</span>
            <span class="n">chunk_text</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">overlap_words</span><span class="p">),</span> <span class="n">chunk_text</span><span class="p">])</span>
                <span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="p">)</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_text</span><span class="p">)</span>
        <span class="n">start</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;paragraph_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="s2">&quot;line_break&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_break</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="recursivecharactersplitter">RecursiveCharacterSplitter<a class="headerlink" href="#recursivecharactersplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.recursive_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter" class="doc doc-heading">
            <code>RecursiveCharacterSplitter</code>


<a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>RecursiveCharacterSplitter splits a given text into overlapping or non-overlapping chunks,
where each chunk is created repeatedly breaking down the text until it reaches the
desired chunk size. This class implements the Langchain RecursiveCharacterTextSplitter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Approximate chunk size, in characters.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number or percentage of overlapping characters between
chunks.</p>
              </div>
            </td>
            <td>
                  <code>0.1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>separators</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="str">str</span>, <span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Character(s) to recursively split sentences.</p>
              </div>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.constants.DEFAULT_RECURSIVE_SEPARATORS">DEFAULT_RECURSIVE_SEPARATORS</span></code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <p>More info about the RecursiveCharacterTextSplitter:
<a href="https://python.langchain.com/docs/how_to/recursive_text_splitter/">Langchain Docs</a>.</p>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/recursive_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RecursiveCharacterSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RecursiveCharacterSplitter splits a given text into overlapping or non-overlapping chunks,</span>
<span class="sd">    where each chunk is created repeatedly breaking down the text until it reaches the</span>
<span class="sd">    desired chunk size. This class implements the Langchain RecursiveCharacterTextSplitter.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Approximate chunk size, in characters.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number or percentage of overlapping characters between</span>
<span class="sd">            chunks.</span>
<span class="sd">        separators (Union[str, List[str]]): Character(s) to recursively split sentences.</span>

<span class="sd">    Notes:</span>
<span class="sd">        More info about the RecursiveCharacterTextSplitter:</span>
<span class="sd">        [Langchain Docs](https://python.langchain.com/docs/how_to/recursive_text_splitter/).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">separators</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="n">DEFAULT_RECURSIVE_SEPARATORS</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">separators</span> <span class="o">=</span> <span class="n">separators</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">separators</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="k">else</span> <span class="p">[</span><span class="n">separators</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text into character-based chunks using a recursive splitting strategy</span>
<span class="sd">        (via Langchain&#39;s `RecursiveCharacterTextSplitter`), supporting configurable separators,</span>
<span class="sd">        chunk size, and overlap.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]): Dictionary containing at least a &#39;text&#39; key (str)</span>
<span class="sd">                and optional document metadata (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If &#39;text&#39; is missing in `reader_output` or is not a string.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import RecursiveCharacterSplitter</span>

<span class="sd">            # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;This is a long document.</span>
<span class="sd">                It will be recursively split into smaller chunks using the specified separators.</span>
<span class="sd">                Each chunk will have some overlap with the next.&quot;,</span>
<span class="sd">                document_name: &quot;sample.txt&quot;,</span>
<span class="sd">                document_path: &quot;/tmp/sample.txt&quot;</span>
<span class="sd">            )</span>

<span class="sd">            splitter = RecursiveCharacterSplitter(chunk_size=40, chunk_overlap=5)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;This is a long document. It will be&#39;, &#39;be recursively split into smaller chunks&#39;, ...]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Determine overlap in characters</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

        <span class="c1"># Split text into sentences</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">chunk_overlap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="n">separators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">texts</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">]</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;recursive_character_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
                <span class="s2">&quot;separators&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.recursive_splitter.RecursiveCharacterSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text into character-based chunks using a recursive splitting strategy
(via Langchain's <code>RecursiveCharacterTextSplitter</code>), supporting configurable separators,
chunk size, and overlap.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str)
and optional document metadata (e.g., 'document_name', 'document_path', etc.).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If 'text' is missing in <code>reader_output</code> or is not a string.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecursiveCharacterSplitter</span>

<span class="c1"># This dictionary has been obtained as the output from a Reader object.</span>
<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;This is a long document.</span>
    <span class="n">It</span> <span class="n">will</span> <span class="n">be</span> <span class="n">recursively</span> <span class="n">split</span> <span class="n">into</span> <span class="n">smaller</span> <span class="n">chunks</span> <span class="n">using</span> <span class="n">the</span> <span class="n">specified</span> <span class="n">separators</span><span class="o">.</span>
    <span class="n">Each</span> <span class="n">chunk</span> <span class="n">will</span> <span class="n">have</span> <span class="n">some</span> <span class="n">overlap</span> <span class="k">with</span> <span class="n">the</span> <span class="nb">next</span><span class="o">.</span><span class="s2">&quot;,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;sample.txt&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/tmp/sample.txt&quot;</span>
<span class="p">)</span>

<span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">40</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;This is a long document. It will be&#39;</span><span class="p">,</span> <span class="s1">&#39;be recursively split into smaller chunks&#39;</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/recursive_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text into character-based chunks using a recursive splitting strategy</span>
<span class="sd">    (via Langchain&#39;s `RecursiveCharacterTextSplitter`), supporting configurable separators,</span>
<span class="sd">    chunk size, and overlap.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]): Dictionary containing at least a &#39;text&#39; key (str)</span>
<span class="sd">            and optional document metadata (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If &#39;text&#39; is missing in `reader_output` or is not a string.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import RecursiveCharacterSplitter</span>

<span class="sd">        # This dictionary has been obtained as the output from a Reader object.</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;This is a long document.</span>
<span class="sd">            It will be recursively split into smaller chunks using the specified separators.</span>
<span class="sd">            Each chunk will have some overlap with the next.&quot;,</span>
<span class="sd">            document_name: &quot;sample.txt&quot;,</span>
<span class="sd">            document_path: &quot;/tmp/sample.txt&quot;</span>
<span class="sd">        )</span>

<span class="sd">        splitter = RecursiveCharacterSplitter(chunk_size=40, chunk_overlap=5)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;This is a long document. It will be&#39;, &#39;be recursively split into smaller chunks&#39;, ...]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Determine overlap in characters</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">overlap</span> <span class="o">&gt;=</span> <span class="n">chunk_size</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be smaller than chunk_size&quot;</span><span class="p">)</span>

    <span class="c1"># Split text into sentences</span>
    <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
        <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
        <span class="n">separators</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="n">texts</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">]</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;recursive_character_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="s2">&quot;separators&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">separators</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="keywordsplitter">KeywordSplitter<a class="headerlink" href="#keywordsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.keyword_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter" class="doc doc-heading">
            <code>KeywordSplitter</code>


<a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>Splitter that chunks text around <em>keyword</em> boundaries using regular expressions.</p>
<p>This splitter searches the input text for one or more <em>keyword patterns</em> (regex)
and creates chunks at each match boundary. You can control how the matched
delimiter is attached to the resulting chunks (before/after/both/none) and apply a
secondary, size-based re-chunking to respect <code>chunk_size</code>.</p>
<p>The splitter emits a :class:<code>~..schema.SplitterOutput</code> with metadata including
per-keyword match counts and raw match spans.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>patterns</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="str">str</span>], <span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>A list of regex pattern strings <strong>or</strong> a mapping of
<code>name -&gt; regex pattern</code>. When a dict is provided, the keys are used in
the metadata counts. When a list is provided, synthetic names are
generated (<code>k0</code>, <code>k1</code>, ...).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>flags</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Standard <code>re</code> flags combined with <code>|</code> (e.g., <code>re.IGNORECASE</code>).</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>include_delimiters</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Where to attach the matched keyword delimiter.
One of <code>"none"</code>, <code>"before"</code>, <code>"after"</code>, <code>"both"</code>.
- <code>before</code> (default) appends the match to the <em>preceding</em> chunk.
- <code>after</code> prepends the match to the <em>following</em> chunk.
- <code>both</code> duplicates the match on both sides.
- <code>none</code> omits the delimiter from both sides.</p>
              </div>
            </td>
            <td>
                  <code>&#39;before&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Target maximum size (in characters) for each chunk. When a
produced chunk exceeds this value, it is <em>soft</em>-wrapped by whitespace
using a greedy strategy.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>All regexes are compiled into <strong>one</strong> alternation with <em>named groups</em> when
  <code>patterns</code> is a dict. This simplifies per-keyword accounting.</li>
<li>If the input text is empty or no matches are found, the entire text
  becomes a single chunk (subject to size-based re-chunking).</li>
</ul>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/keyword_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">KeywordSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splitter that chunks text around *keyword* boundaries using regular expressions.</span>

<span class="sd">    This splitter searches the input text for one or more *keyword patterns* (regex)</span>
<span class="sd">    and creates chunks at each match boundary. You can control how the matched</span>
<span class="sd">    delimiter is attached to the resulting chunks (before/after/both/none) and apply a</span>
<span class="sd">    secondary, size-based re-chunking to respect ``chunk_size``.</span>

<span class="sd">    The splitter emits a :class:`~..schema.SplitterOutput` with metadata including</span>
<span class="sd">    per-keyword match counts and raw match spans.</span>

<span class="sd">    Args:</span>
<span class="sd">        patterns (Union[List[str], Dict[str, str]]): A list of regex pattern strings **or** a mapping of</span>
<span class="sd">            ``name -&gt; regex pattern``. When a dict is provided, the keys are used in</span>
<span class="sd">            the metadata counts. When a list is provided, synthetic names are</span>
<span class="sd">            generated (``k0``, ``k1``, ...).</span>
<span class="sd">        flags (int): Standard ``re`` flags combined with ``|`` (e.g., ``re.IGNORECASE``).</span>
<span class="sd">        include_delimiters (str): Where to attach the matched keyword delimiter.</span>
<span class="sd">            One of ``&quot;none&quot;``, ``&quot;before&quot;``, ``&quot;after&quot;``, ``&quot;both&quot;``.</span>
<span class="sd">            - ``before`` (default) appends the match to the *preceding* chunk.</span>
<span class="sd">            - ``after`` prepends the match to the *following* chunk.</span>
<span class="sd">            - ``both`` duplicates the match on both sides.</span>
<span class="sd">            - ``none`` omits the delimiter from both sides.</span>
<span class="sd">        chunk_size (int): Target maximum size (in characters) for each chunk. When a</span>
<span class="sd">            produced chunk exceeds this value, it is *soft*-wrapped by whitespace</span>
<span class="sd">            using a greedy strategy.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - All regexes are compiled into **one** alternation with *named groups* when</span>
<span class="sd">          ``patterns`` is a dict. This simplifies per-keyword accounting.</span>
<span class="sd">        - If the input text is empty or no matches are found, the entire text</span>
<span class="sd">          becomes a single chunk (subject to size-based re-chunking).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">patterns</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">include_delimiters</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;before&quot;</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the KeywordSplitter.</span>

<span class="sd">        Args:</span>
<span class="sd">            patterns (Union[List[str], Dict[str, str]]): Keyword regex patterns.</span>
<span class="sd">            flags (int): Regex flags.</span>
<span class="sd">            include_delimiters (str): How to include delimiters (before, after, both, none).</span>
<span class="sd">            chunk_size (int): Max chunk size in characters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_include_delimiters</span><span class="p">(</span><span class="n">include_delimiters</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pattern_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_patterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split ReaderOutput into keyword-delimited chunks and build structured output.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): Input document and metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Output structure with chunked text and metadata.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Ensure document_id is present so it propagates (fixes metadata test)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">:</span>
            <span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

        <span class="c1"># Primary split by keyword matches (names used for counts)</span>
        <span class="n">raw_chunks</span><span class="p">,</span> <span class="n">match_spans</span><span class="p">,</span> <span class="n">match_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_by_keywords</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Secondary size-based re-chunking to respect chunk_size</span>
        <span class="n">sized_chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">raw_chunks</span><span class="p">:</span>
            <span class="n">sized_chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soft_wrap</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">sized_chunks</span><span class="p">:</span>
            <span class="n">sized_chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="c1"># Generate IDs</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sized_chunks</span><span class="p">))</span>

        <span class="c1"># Build metadata (ensure counts/spans are always present)</span>
        <span class="n">matches_meta</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_name</span><span class="p">(</span><span class="n">match_names</span><span class="p">),</span>
            <span class="s2">&quot;spans&quot;</span><span class="p">:</span> <span class="n">match_spans</span><span class="p">,</span>
            <span class="s2">&quot;include_delimiters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span><span class="p">,</span>
            <span class="s2">&quot;flags&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
            <span class="s2">&quot;pattern_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern_names</span><span class="p">,</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
            <span class="n">reader_output</span><span class="o">=</span><span class="n">reader_output</span><span class="p">,</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">sized_chunks</span><span class="p">,</span>
            <span class="n">chunk_ids</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">matches_meta</span><span class="o">=</span><span class="n">matches_meta</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="c1"># ---- Internals ------------------------------------------------------ #</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_validate_include_delimiters</span><span class="p">(</span><span class="n">value</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Validate and normalize include_delimiters argument.</span>

<span class="sd">        Args:</span>
<span class="sd">            value (str): One of {&quot;none&quot;, &quot;before&quot;, &quot;after&quot;, &quot;both&quot;}.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Normalized delimiter mode.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the mode is invalid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">allowed</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;before&quot;</span><span class="p">,</span> <span class="s2">&quot;after&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">}</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">value</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">allowed</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;include_delimiters must be one of </span><span class="si">{</span><span class="nb">sorted</span><span class="p">(</span><span class="n">allowed</span><span class="p">)</span><span class="si">}</span><span class="s2">, got </span><span class="si">{</span><span class="n">value</span><span class="si">!r}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">v</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_compile_patterns</span><span class="p">(</span>
        <span class="n">patterns</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span> <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Pattern</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compile patterns into a single alternation regex.</span>

<span class="sd">        If a dict is given, build a pattern with **named** groups to preserve the</span>
<span class="sd">        provided names. If a list is given, synthesize names (k0, k1, ...).</span>

<span class="sd">        Args:</span>
<span class="sd">            patterns (Union[List[str], Dict[str, str]]): Patterns or mapping.</span>
<span class="sd">            flags (int): Regex flags.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[List[str], Pattern[str]]: Names and compiled regex.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">names</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">patterns</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;(?P&lt;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">pat</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">pat</span> <span class="ow">in</span> <span class="n">patterns</span><span class="o">.</span><span class="n">items</span><span class="p">()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">names</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;k</span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">patterns</span><span class="p">))]</span>
            <span class="n">parts</span> <span class="o">=</span> <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;(?P&lt;</span><span class="si">{</span><span class="n">n</span><span class="si">}</span><span class="s2">&gt;</span><span class="si">{</span><span class="n">pat</span><span class="si">}</span><span class="s2">)&quot;</span> <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">pat</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">patterns</span><span class="p">)]</span>

        <span class="n">combined</span> <span class="o">=</span> <span class="s2">&quot;|&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">parts</span><span class="p">)</span> <span class="k">if</span> <span class="n">parts</span> <span class="k">else</span> <span class="sa">r</span><span class="s2">&quot;(?!x)x&quot;</span>  <span class="c1"># never matches if empty</span>
        <span class="n">compiled</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">combined</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">names</span><span class="p">,</span> <span class="n">compiled</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_split_by_keywords</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">text</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Split ``text`` around matches of ``self.compiled``.</span>

<span class="sd">        Respects include_delimiters in {&quot;before&quot;, &quot;after&quot;, &quot;both&quot;, &quot;none&quot;}.</span>

<span class="sd">        Args:</span>
<span class="sd">            text (str): The text to split.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[List[str], List[Tuple[int, int]], List[str]]:</span>
<span class="sd">                (chunks, spans, names) where `chunks` are before size re-wrapping,</span>
<span class="sd">                spans are (start, end) tuples, and names are group names for each match.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_append_chunk</span><span class="p">(</span><span class="n">acc</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">chunk</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Keep only non-empty (after strip) chunks here; final fallback to [&quot;&quot;] is done by caller</span>
            <span class="k">if</span> <span class="n">chunk</span> <span class="ow">and</span> <span class="n">chunk</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="n">acc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">spans</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">names</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="n">matches</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">compiled</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="n">last_idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">pending_prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>  <span class="c1"># used when include_delimiters is &quot;after&quot; or &quot;both&quot;</span>

        <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">matches</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">span</span><span class="p">()</span>
            <span class="n">match_txt</span> <span class="o">=</span> <span class="n">text</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="n">group_name</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">lastgroup</span> <span class="ow">or</span> <span class="s2">&quot;unknown&quot;</span>

            <span class="n">spans</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="n">names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group_name</span><span class="p">)</span>

            <span class="c1"># Build the piece between last match end and this match start, prefixing any pending delimiter</span>
            <span class="n">before_piece</span> <span class="o">=</span> <span class="n">pending_prefix</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="n">last_idx</span><span class="p">:</span><span class="n">start</span><span class="p">]</span>
            <span class="n">pending_prefix</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

            <span class="c1"># Attach delimiter to the left side if requested</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;before&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">):</span>
                <span class="n">before_piece</span> <span class="o">+=</span> <span class="n">match_txt</span>

            <span class="n">_append_chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">before_piece</span><span class="p">)</span>

            <span class="c1"># If delimiter should be on the right, carry it forward to prefix next chunk</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;after&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">):</span>
                <span class="n">pending_prefix</span> <span class="o">=</span> <span class="n">match_txt</span>

            <span class="n">last_idx</span> <span class="o">=</span> <span class="n">end</span>

        <span class="c1"># Remainder after the last match (may contain pending_prefix)</span>
        <span class="n">remainder</span> <span class="o">=</span> <span class="n">pending_prefix</span> <span class="o">+</span> <span class="n">text</span><span class="p">[</span><span class="n">last_idx</span><span class="p">:]</span>
        <span class="n">_append_chunk</span><span class="p">(</span><span class="n">chunks</span><span class="p">,</span> <span class="n">remainder</span><span class="p">)</span>

        <span class="c1"># If no non-empty chunks were appended, return a single empty chunk (tests expect this)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span> <span class="n">spans</span><span class="p">,</span> <span class="n">names</span>

        <span class="c1"># normalize whitespace trimming for each chunk</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">chunks</span> <span class="k">if</span> <span class="n">c</span> <span class="ow">and</span> <span class="n">c</span><span class="o">.</span><span class="n">strip</span><span class="p">()]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">],</span> <span class="n">spans</span><span class="p">,</span> <span class="n">names</span>

        <span class="k">return</span> <span class="n">chunks</span><span class="p">,</span> <span class="n">spans</span><span class="p">,</span> <span class="n">names</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_soft_wrap</span><span class="p">(</span><span class="n">text</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">max_size</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Greedy soft-wrap by whitespace to respect ``max_size``.</span>

<span class="sd">        - If ``len(text) &lt;= max_size``: return ``[text]``.</span>
<span class="sd">        - Else: split on whitespace and rebuild lines greedily.</span>
<span class="sd">        - If a single token is longer than ``max_size``, it is hard-split.</span>

<span class="sd">        Args:</span>
<span class="sd">            text (str): Text to wrap.</span>
<span class="sd">            max_size (int): Maximum chunk size.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[str]: List of size-constrained chunks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">max_size</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_size</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">text</span><span class="p">]</span> <span class="k">if</span> <span class="n">text</span> <span class="k">else</span> <span class="p">[]</span>

        <span class="n">tokens</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\S+|\s+&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
        <span class="n">out</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">tok</span> <span class="ow">in</span> <span class="n">tokens</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">buf</span> <span class="o">+=</span> <span class="n">tok</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">buf</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
                <span class="n">buf</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="c1"># token alone is too big -&gt; hard split</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">tok</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">max_size</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tok</span><span class="p">[:</span><span class="n">max_size</span><span class="p">])</span>
                <span class="n">tok</span> <span class="o">=</span> <span class="n">tok</span><span class="p">[</span><span class="n">max_size</span><span class="p">:]</span>
            <span class="n">buf</span> <span class="o">=</span> <span class="n">tok</span>
        <span class="k">if</span> <span class="n">buf</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">buf</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">out</span><span class="p">)</span> <span class="k">if</span> <span class="n">c</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_count_by_name</span><span class="p">(</span><span class="n">names</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">str</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Aggregate match counts by group name (k0/k1/... for list patterns, custom names for dict).</span>

<span class="sd">        Args:</span>
<span class="sd">            names (Iterable[str]): Group names.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Dict[str, int]: Count of matches per group name.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">counts</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">names</span><span class="p">:</span>
            <span class="n">counts</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">counts</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">counts</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_build_output</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">,</span>
        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">chunk_ids</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span>
        <span class="n">matches_meta</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">object</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assemble a :class:`SplitterOutput` carrying over reader metadata.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): Input document and metadata.</span>
<span class="sd">            chunks (List[str]): Final list of chunks.</span>
<span class="sd">            chunk_ids (List[str]): Unique chunk IDs.</span>
<span class="sd">            matches_meta (Dict[str, object]): Keyword matches metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Populated output object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;keyword&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;include_delimiters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span><span class="p">,</span>
                <span class="s2">&quot;flags&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;pattern_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern_names</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="p">{</span>
                <span class="o">**</span><span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">metadata</span> <span class="ow">or</span> <span class="p">{}),</span>
                <span class="s2">&quot;keyword_matches&quot;</span><span class="p">:</span> <span class="n">matches_meta</span><span class="p">,</span>
            <span class="p">},</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">include_delimiters</span><span class="o">=</span><span class="s1">&#39;before&#39;</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Initialize the KeywordSplitter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>patterns</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="typing.List">List</span>[<span title="str">str</span>], <span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keyword regex patterns.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>flags</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Regex flags.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>include_delimiters</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>How to include delimiters (before, after, both, none).</p>
              </div>
            </td>
            <td>
                  <code>&#39;before&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Max chunk size in characters.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/keyword_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">patterns</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">],</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]],</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">flags</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="n">include_delimiters</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;before&quot;</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the KeywordSplitter.</span>

<span class="sd">    Args:</span>
<span class="sd">        patterns (Union[List[str], Dict[str, str]]): Keyword regex patterns.</span>
<span class="sd">        flags (int): Regex flags.</span>
<span class="sd">        include_delimiters (str): How to include delimiters (before, after, both, none).</span>
<span class="sd">        chunk_size (int): Max chunk size in characters.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_validate_include_delimiters</span><span class="p">(</span><span class="n">include_delimiters</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">pattern_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">compiled</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compile_patterns</span><span class="p">(</span><span class="n">patterns</span><span class="p">,</span> <span class="n">flags</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">flags</span> <span class="o">=</span> <span class="n">flags</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.keyword_splitter.KeywordSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Split ReaderOutput into keyword-delimited chunks and build structured output.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Input document and metadata.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Output structure with chunked text and metadata.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/keyword_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split ReaderOutput into keyword-delimited chunks and build structured output.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (ReaderOutput): Input document and metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Output structure with chunked text and metadata.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># Ensure document_id is present so it propagates (fixes metadata test)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">:</span>
        <span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">uuid</span><span class="o">.</span><span class="n">uuid4</span><span class="p">())</span>

    <span class="c1"># Primary split by keyword matches (names used for counts)</span>
    <span class="n">raw_chunks</span><span class="p">,</span> <span class="n">match_spans</span><span class="p">,</span> <span class="n">match_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_by_keywords</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Secondary size-based re-chunking to respect chunk_size</span>
    <span class="n">sized_chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ch</span> <span class="ow">in</span> <span class="n">raw_chunks</span><span class="p">:</span>
        <span class="n">sized_chunks</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_soft_wrap</span><span class="p">(</span><span class="n">ch</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">))</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">sized_chunks</span><span class="p">:</span>
        <span class="n">sized_chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

    <span class="c1"># Generate IDs</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sized_chunks</span><span class="p">))</span>

    <span class="c1"># Build metadata (ensure counts/spans are always present)</span>
    <span class="n">matches_meta</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;counts&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_count_by_name</span><span class="p">(</span><span class="n">match_names</span><span class="p">),</span>
        <span class="s2">&quot;spans&quot;</span><span class="p">:</span> <span class="n">match_spans</span><span class="p">,</span>
        <span class="s2">&quot;include_delimiters&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">include_delimiters</span><span class="p">,</span>
        <span class="s2">&quot;flags&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">flags</span><span class="p">,</span>
        <span class="s2">&quot;pattern_names&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">pattern_names</span><span class="p">,</span>
        <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_output</span><span class="p">(</span>
        <span class="n">reader_output</span><span class="o">=</span><span class="n">reader_output</span><span class="p">,</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">sized_chunks</span><span class="p">,</span>
        <span class="n">chunk_ids</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">matches_meta</span><span class="o">=</span><span class="n">matches_meta</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="headersplitter">HeaderSplitter<a class="headerlink" href="#headersplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.header_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.header_splitter.HeaderSplitter" class="doc doc-heading">
            <code>HeaderSplitter</code>


<a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>Split HTML or Markdown documents into chunks by header levels (H1H6).</p>
<ul>
<li>If the input looks like HTML, it is first converted to Markdown using the
  project's HtmlToMarkdown utility, which emits ATX-style headings (<code>#</code>, <code>##</code>, ...).</li>
<li>If the input is Markdown, Setext-style headings (underlines with <code>===</code> / <code>---</code>)
  are normalized to ATX so headers are reliably detected.</li>
<li>Splitting is performed with LangChain's MarkdownHeaderTextSplitter.</li>
<li>If no headers are detected after conversion/normalization, a safe fallback
  splitter (RecursiveCharacterTextSplitter) is used to avoid returning a single,
  excessively large chunk.</li>
</ul>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Size hint for fallback splitting; not used by
header splitting itself. Defaults to 1000.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>headers_to_split_on</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Semantic header names like
["Header 1", "Header 2"]. If None, all levels 16 are enabled.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>group_header_with_content</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True (default), headers are
kept with their following content (strip_headers=False). If False,
headers are stripped from chunks (strip_headers=True).</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">HeaderSplitter</span>

<span class="n">splitter</span> <span class="o">=</span> <span class="n">HeaderSplitter</span><span class="p">(</span><span class="n">headers_to_split_on</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;Header 1&quot;</span><span class="p">,</span> <span class="s2">&quot;Header 2&quot;</span><span class="p">,</span> <span class="s2">&quot;Header 3&quot;</span><span class="p">])</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>  <span class="c1"># reader_output.text may be HTML or MD</span>
<span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">chunks</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;--- Chunk </span><span class="si">{</span><span class="n">idx</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> ---&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>
</code></pre></div>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/header_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">HeaderSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split HTML or Markdown documents into chunks by header levels (H1H6).</span>

<span class="sd">    - If the input looks like HTML, it is first converted to Markdown using the</span>
<span class="sd">      project&#39;s HtmlToMarkdown utility, which emits ATX-style headings (`#`, `##`, ...).</span>
<span class="sd">    - If the input is Markdown, Setext-style headings (underlines with `===` / `---`)</span>
<span class="sd">      are normalized to ATX so headers are reliably detected.</span>
<span class="sd">    - Splitting is performed with LangChain&#39;s MarkdownHeaderTextSplitter.</span>
<span class="sd">    - If no headers are detected after conversion/normalization, a safe fallback</span>
<span class="sd">      splitter (RecursiveCharacterTextSplitter) is used to avoid returning a single,</span>
<span class="sd">      excessively large chunk.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int, optional): Size hint for fallback splitting; not used by</span>
<span class="sd">            header splitting itself. Defaults to 1000.</span>
<span class="sd">        headers_to_split_on (Optional[List[str]]): Semantic header names like</span>
<span class="sd">            [&quot;Header 1&quot;, &quot;Header 2&quot;]. If None, all levels 16 are enabled.</span>
<span class="sd">        group_header_with_content (bool, optional): If True (default), headers are</span>
<span class="sd">            kept with their following content (strip_headers=False). If False,</span>
<span class="sd">            headers are stripped from chunks (strip_headers=True).</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import HeaderSplitter</span>

<span class="sd">        splitter = HeaderSplitter(headers_to_split_on=[&quot;Header 1&quot;, &quot;Header 2&quot;, &quot;Header 3&quot;])</span>
<span class="sd">        output = splitter.split(reader_output)  # reader_output.text may be HTML or MD</span>
<span class="sd">        for idx, chunk in enumerate(output.chunks):</span>
<span class="sd">            print(f&quot;--- Chunk {idx+1} ---&quot;)</span>
<span class="sd">            print(chunk)</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">headers_to_split_on</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">group_header_with_content</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize the HeaderSplitter.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunk_size (int): Used by fallback character splitter if no headers are found.</span>
<span class="sd">            headers_to_split_on (Optional[List[str]]): Semantic headers, e.g. [&quot;Header 1&quot;, &quot;Header 2&quot;].</span>
<span class="sd">                Defaults to all levels 16.</span>
<span class="sd">            group_header_with_content (bool): Keep headers attached to following content if True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="c1"># Default to all 6 levels for robust splitting unless caller narrows it.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">headers_to_split_on</span> <span class="o">=</span> <span class="n">headers_to_split_on</span> <span class="ow">or</span> <span class="p">[</span>
            <span class="sa">f</span><span class="s2">&quot;Header </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">group_header_with_content</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_make_tuples</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filetype</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Convert semantic header names (e.g., &quot;Header 2&quot;) into Markdown tokens.</span>

<span class="sd">        Args:</span>
<span class="sd">            filetype (str): Only &quot;md&quot; is supported (HTML is converted to MD first).</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[Tuple[str, str]]: Tuples of (header_token, semantic_name), e.g. (&quot;##&quot;, &quot;Header 2&quot;).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tuples</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">header</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_to_split_on</span><span class="p">:</span>
            <span class="n">lvl</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_header_level</span><span class="p">(</span><span class="n">header</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;md&quot;</span><span class="p">:</span>
                <span class="n">tuples</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="s2">&quot;#&quot;</span> <span class="o">*</span> <span class="n">lvl</span><span class="p">,</span> <span class="n">header</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unsupported filetype: </span><span class="si">{</span><span class="n">filetype</span><span class="si">!r}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tuples</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_header_level</span><span class="p">(</span><span class="n">header</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extract numeric level from a header name like &quot;Header 2&quot;.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the header string is not of the expected form.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;header\s*(\d+)&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">m</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Invalid header: </span><span class="si">{</span><span class="n">header</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_guess_filetype</span><span class="p">(</span><span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Heuristically determine whether the input is HTML or Markdown.</span>

<span class="sd">        Checks filename extensions first, then looks for HTML elements as a hint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.html&quot;</span><span class="p">,</span> <span class="s2">&quot;.htm&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s2">&quot;html&quot;</span>
        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">endswith</span><span class="p">((</span><span class="s2">&quot;.md&quot;</span><span class="p">,</span> <span class="s2">&quot;.markdown&quot;</span><span class="p">)):</span>
            <span class="k">return</span> <span class="s2">&quot;md&quot;</span>

        <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^h[1-6]$&quot;</span><span class="p">))</span> <span class="ow">or</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;div&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="s2">&quot;html&quot;</span>
        <span class="k">return</span> <span class="s2">&quot;md&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_normalize_setext</span><span class="p">(</span><span class="n">md_text</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Normalize Setext-style headings to ATX so MarkdownHeaderTextSplitter can detect them.</span>

<span class="sd">        H1:  Title\\n====    # Title</span>
<span class="sd">        H2:  Title\\n----    ## Title</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># H1 underlines</span>
        <span class="n">md_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^(?P&lt;t&gt;[^\n]+)\n=+\s*$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;# \g&lt;t&gt;&quot;</span><span class="p">,</span> <span class="n">md_text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="c1"># H2 underlines</span>
        <span class="n">md_text</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^(?P&lt;t&gt;[^\n]+)\n-+\s*$&quot;</span><span class="p">,</span> <span class="sa">r</span><span class="s2">&quot;## \g&lt;t&gt;&quot;</span><span class="p">,</span> <span class="n">md_text</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">md_text</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform header-based splitting with HTMLMarkdown conversion and safe fallback.</span>

<span class="sd">        Steps:</span>
<span class="sd">          1) Detect filetype (HTML/MD).</span>
<span class="sd">          2) If HTML, convert to Markdown with HtmlToMarkdown (emits ATX headings).</span>
<span class="sd">          3) If Markdown, normalize Setext headings to ATX.</span>
<span class="sd">          4) Split by headers via MarkdownHeaderTextSplitter.</span>
<span class="sd">          5) If no headers found, fallback to RecursiveCharacterTextSplitter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reader_output.text is empty or None&quot;</span><span class="p">)</span>

        <span class="n">filetype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guess_filetype</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
        <span class="n">tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tuples</span><span class="p">(</span><span class="s2">&quot;md&quot;</span><span class="p">)</span>  <span class="c1"># Always work in Markdown space.</span>

        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>

        <span class="c1"># HTML  Markdown using the project&#39;s converter</span>
        <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
            <span class="n">text</span> <span class="o">=</span> <span class="n">HtmlToMarkdown</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Normalize Setext headings if already Markdown</span>
            <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_setext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Detect presence of ATX headers (after conversion/normalization)</span>
        <span class="n">has_headers</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?m)^\s*#{1,6}\s+\S&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>

        <span class="c1"># Configure header splitter. group_header_with_content -&gt; strip_headers False</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">MarkdownHeaderTextSplitter</span><span class="p">(</span>
            <span class="n">headers_to_split_on</span><span class="o">=</span><span class="n">tuples</span><span class="p">,</span>
            <span class="n">return_each_line</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">strip_headers</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">docs</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_headers</span> <span class="k">else</span> <span class="p">[]</span>
        <span class="c1"># Fallback if no headers were found</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">docs</span><span class="p">:</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1000</span><span class="p">),</span>
                <span class="n">chunk_overlap</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)),</span>
            <span class="p">)</span>
            <span class="n">docs</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)),</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;header_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;headers_to_split_on&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_to_split_on</span><span class="p">,</span>
                <span class="s2">&quot;group_header_with_content&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">(),</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">headers_to_split_on</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">group_header_with_content</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Initialize the HeaderSplitter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Used by fallback character splitter if no headers are found.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>headers_to_split_on</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="typing.List">List</span>[<span title="str">str</span>]]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Semantic headers, e.g. ["Header 1", "Header 2"].
Defaults to all levels 16.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>group_header_with_content</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Keep headers attached to following content if True.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/header_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="n">headers_to_split_on</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">group_header_with_content</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize the HeaderSplitter.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Used by fallback character splitter if no headers are found.</span>
<span class="sd">        headers_to_split_on (Optional[List[str]]): Semantic headers, e.g. [&quot;Header 1&quot;, &quot;Header 2&quot;].</span>
<span class="sd">            Defaults to all levels 16.</span>
<span class="sd">        group_header_with_content (bool): Keep headers attached to following content if True.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="c1"># Default to all 6 levels for robust splitting unless caller narrows it.</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">headers_to_split_on</span> <span class="o">=</span> <span class="n">headers_to_split_on</span> <span class="ow">or</span> <span class="p">[</span>
        <span class="sa">f</span><span class="s2">&quot;Header </span><span class="si">{</span><span class="n">i</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">)</span>
    <span class="p">]</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">group_header_with_content</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.header_splitter.HeaderSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Perform header-based splitting with HTMLMarkdown conversion and safe fallback.</p>


<details class="steps" open>
  <summary>Steps</summary>
  <p>1) Detect filetype (HTML/MD).
2) If HTML, convert to Markdown with HtmlToMarkdown (emits ATX headings).
3) If Markdown, normalize Setext headings to ATX.
4) Split by headers via MarkdownHeaderTextSplitter.
5) If no headers found, fallback to RecursiveCharacterTextSplitter.</p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/header_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Perform header-based splitting with HTMLMarkdown conversion and safe fallback.</span>

<span class="sd">    Steps:</span>
<span class="sd">      1) Detect filetype (HTML/MD).</span>
<span class="sd">      2) If HTML, convert to Markdown with HtmlToMarkdown (emits ATX headings).</span>
<span class="sd">      3) If Markdown, normalize Setext headings to ATX.</span>
<span class="sd">      4) Split by headers via MarkdownHeaderTextSplitter.</span>
<span class="sd">      5) If no headers found, fallback to RecursiveCharacterTextSplitter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;reader_output.text is empty or None&quot;</span><span class="p">)</span>

    <span class="n">filetype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_guess_filetype</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
    <span class="n">tuples</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_make_tuples</span><span class="p">(</span><span class="s2">&quot;md&quot;</span><span class="p">)</span>  <span class="c1"># Always work in Markdown space.</span>

    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>

    <span class="c1"># HTML  Markdown using the project&#39;s converter</span>
    <span class="k">if</span> <span class="n">filetype</span> <span class="o">==</span> <span class="s2">&quot;html&quot;</span><span class="p">:</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">HtmlToMarkdown</span><span class="p">()</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># Normalize Setext headings if already Markdown</span>
        <span class="n">text</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_normalize_setext</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Detect presence of ATX headers (after conversion/normalization)</span>
    <span class="n">has_headers</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;(?m)^\s*#{1,6}\s+\S&quot;</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>

    <span class="c1"># Configure header splitter. group_header_with_content -&gt; strip_headers False</span>
    <span class="n">splitter</span> <span class="o">=</span> <span class="n">MarkdownHeaderTextSplitter</span><span class="p">(</span>
        <span class="n">headers_to_split_on</span><span class="o">=</span><span class="n">tuples</span><span class="p">,</span>
        <span class="n">return_each_line</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="n">strip_headers</span><span class="o">=</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="n">docs</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span> <span class="k">if</span> <span class="n">has_headers</span> <span class="k">else</span> <span class="p">[]</span>
    <span class="c1"># Fallback if no headers were found</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">docs</span><span class="p">:</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span> <span class="ow">or</span> <span class="mi">1000</span><span class="p">),</span>
            <span class="n">chunk_overlap</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="mi">200</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">)</span> <span class="o">//</span> <span class="mi">10</span><span class="p">)),</span>
        <span class="p">)</span>
        <span class="n">docs</span> <span class="o">=</span> <span class="n">rc</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">docs</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">)),</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;header_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;headers_to_split_on&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">headers_to_split_on</span><span class="p">,</span>
            <span class="s2">&quot;group_header_with_content&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">group_header_with_content</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">(),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="recursivejsonsplitter">RecursiveJSONSplitter<a class="headerlink" href="#recursivejsonsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.json_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter" class="doc doc-heading">
            <code>RecursiveJSONSplitter</code>


<a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>RecursiveJSONSplitter splits a JSON string or structure into overlapping or non-overlapping
chunks, using the Langchain RecursiveJsonSplitter. This splitter is designed to recursively
break down JSON data (including nested objects and arrays) into manageable pieces based on keys,
arrays, or other separators, until the desired chunk size is reached.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum chunk size, measured in the number of characters per chunk.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>min_chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Minimum chunk size, in characters.</p>
              </div>
            </td>
            <td>
                  <code>200</code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <p>See <a href="https://python.langchain.com/api_reference/text_splitters/json/langchain_text_splitters.json.RecursiveJsonSplitter.html#langchain_text_splitters.json.RecursiveJsonSplitter">Langchain Docs on RecursiveJsonSplitter</a>.</p>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/json_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span>
<span class="normal">19</span>
<span class="normal">20</span>
<span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span>
<span class="normal">99</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RecursiveJSONSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RecursiveJSONSplitter splits a JSON string or structure into overlapping or non-overlapping</span>
<span class="sd">    chunks, using the Langchain RecursiveJsonSplitter. This splitter is designed to recursively</span>
<span class="sd">    break down JSON data (including nested objects and arrays) into manageable pieces based on keys,</span>
<span class="sd">    arrays, or other separators, until the desired chunk size is reached.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum chunk size, measured in the number of characters per chunk.</span>
<span class="sd">        min_chunk_size (int): Minimum chunk size, in characters.</span>

<span class="sd">    Notes:</span>
<span class="sd">        See [Langchain Docs on RecursiveJsonSplitter](https://python.langchain.com/api_reference/text_splitters/json/langchain_text_splitters.json.RecursiveJsonSplitter.html#langchain_text_splitters.json.RecursiveJsonSplitter).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">min_chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">200</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">min_chunk_size</span> <span class="o">=</span> <span class="n">min_chunk_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input JSON text from the reader_output dictionary into recursively chunked pieces,</span>
<span class="sd">        allowing for overlap by number or percentage of characters.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">                (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the &#39;text&#39; field is missing from reader_output.</span>
<span class="sd">            json.JSONDecodeError: If the &#39;text&#39; field contains invalid JSON.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import RecursiveJSONSplitter</span>

<span class="sd">            # This dictionary has been obtained from `VanillaReader`</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;, &quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;}, {&quot;name&quot;: &quot;Bob&quot;}]}}&#39;</span>
<span class="sd">                document_name: &quot;company_data.json&quot;,</span>
<span class="sd">                document_path: &quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/company_data.json&quot;,</span>
<span class="sd">                document_id: &quot;doc123&quot;,</span>
<span class="sd">                conversion_method: &quot;vanilla&quot;,</span>
<span class="sd">                ocr_method: None</span>
<span class="sd">            )</span>
<span class="sd">            splitter = RecursiveJSONSplitter(chunk_size=100, min_chunk_size=20)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;}}&#39;,</span>
<span class="sd">            &#39;{&quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;},</span>
<span class="sd">            {&quot;name&quot;: &quot;Bob&quot;}]}&#39;]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

        <span class="c1"># Split text into smaller JSON chunks</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveJsonSplitter</span><span class="p">(</span>
            <span class="n">max_chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">min_chunk_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_chunk_size</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">json_data</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">convert_lists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Generate chunk_ids and metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;recursive_json_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;max_chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;min_chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_chunk_size</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.json_splitter.RecursiveJSONSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input JSON text from the reader_output dictionary into recursively chunked pieces,
allowing for overlap by number or percentage of characters.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str) and optional document metadata
(e.g., 'document_name', 'document_path', etc.).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the 'text' field is missing from reader_output.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="json.JSONDecodeError">JSONDecodeError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the 'text' field contains invalid JSON.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">RecursiveJSONSplitter</span>

<span class="c1"># This dictionary has been obtained from `VanillaReader`</span>
<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s1">&#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;, &quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;}, {&quot;name&quot;: &quot;Bob&quot;}]}}&#39;</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;company_data.json&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/company_data.json&quot;</span><span class="p">,</span>
    <span class="n">document_id</span><span class="p">:</span> <span class="s2">&quot;doc123&quot;</span><span class="p">,</span>
    <span class="n">conversion_method</span><span class="p">:</span> <span class="s2">&quot;vanilla&quot;</span><span class="p">,</span>
    <span class="n">ocr_method</span><span class="p">:</span> <span class="kc">None</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveJSONSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">min_chunk_size</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;}}&#39;</span><span class="p">,</span>
<span class="s1">&#39;{&quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;},</span>
<span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="s2">&quot;Bob&quot;</span><span class="p">}]}</span><span class="s1">&#39;]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/json_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span>
<span class="normal">33</span>
<span class="normal">34</span>
<span class="normal">35</span>
<span class="normal">36</span>
<span class="normal">37</span>
<span class="normal">38</span>
<span class="normal">39</span>
<span class="normal">40</span>
<span class="normal">41</span>
<span class="normal">42</span>
<span class="normal">43</span>
<span class="normal">44</span>
<span class="normal">45</span>
<span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span>
<span class="normal">70</span>
<span class="normal">71</span>
<span class="normal">72</span>
<span class="normal">73</span>
<span class="normal">74</span>
<span class="normal">75</span>
<span class="normal">76</span>
<span class="normal">77</span>
<span class="normal">78</span>
<span class="normal">79</span>
<span class="normal">80</span>
<span class="normal">81</span>
<span class="normal">82</span>
<span class="normal">83</span>
<span class="normal">84</span>
<span class="normal">85</span>
<span class="normal">86</span>
<span class="normal">87</span>
<span class="normal">88</span>
<span class="normal">89</span>
<span class="normal">90</span>
<span class="normal">91</span>
<span class="normal">92</span>
<span class="normal">93</span>
<span class="normal">94</span>
<span class="normal">95</span>
<span class="normal">96</span>
<span class="normal">97</span>
<span class="normal">98</span>
<span class="normal">99</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input JSON text from the reader_output dictionary into recursively chunked pieces,</span>
<span class="sd">    allowing for overlap by number or percentage of characters.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata</span>
<span class="sd">            (e.g., &#39;document_name&#39;, &#39;document_path&#39;, etc.).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the &#39;text&#39; field is missing from reader_output.</span>
<span class="sd">        json.JSONDecodeError: If the &#39;text&#39; field contains invalid JSON.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import RecursiveJSONSplitter</span>

<span class="sd">        # This dictionary has been obtained from `VanillaReader`</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;, &quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;}, {&quot;name&quot;: &quot;Bob&quot;}]}}&#39;</span>
<span class="sd">            document_name: &quot;company_data.json&quot;,</span>
<span class="sd">            document_path: &quot;/https://raw.githubusercontent.com/andreshere00/Splitter_MR/refs/heads/main/data/company_data.json&quot;,</span>
<span class="sd">            document_id: &quot;doc123&quot;,</span>
<span class="sd">            conversion_method: &quot;vanilla&quot;,</span>
<span class="sd">            ocr_method: None</span>
<span class="sd">        )</span>
<span class="sd">        splitter = RecursiveJSONSplitter(chunk_size=100, min_chunk_size=20)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;{&quot;company&quot;: {&quot;name&quot;: &quot;TechCorp&quot;}}&#39;,</span>
<span class="sd">        &#39;{&quot;employees&quot;: [{&quot;name&quot;: &quot;Alice&quot;},</span>
<span class="sd">        {&quot;name&quot;: &quot;Bob&quot;}]}&#39;]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="p">)</span>

    <span class="c1"># Split text into smaller JSON chunks</span>
    <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveJsonSplitter</span><span class="p">(</span>
        <span class="n">max_chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
        <span class="n">min_chunk_size</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_chunk_size</span><span class="p">),</span>
    <span class="p">)</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">json_data</span><span class="o">=</span><span class="n">text</span><span class="p">,</span> <span class="n">convert_lists</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Generate chunk_ids and metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;recursive_json_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;max_chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;min_chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">min_chunk_size</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="htmltagsplitter">HTMLTagSplitter<a class="headerlink" href="#htmltagsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.html_tag_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter" class="doc doc-heading">
            <code>HTMLTagSplitter</code>


<a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>HTMLTagSplitter splits HTML content into chunks based on a specified tag.
Supports batching and optional Markdown conversion.</p>


<details class="behavior" open>
  <summary>Behavior</summary>
  <ul>
<li>When <code>tag</code> is specified (e.g., tag="div"), finds all matching elements.</li>
<li>When <code>tag</code> is None, splits by the most frequent and shallowest tag.</li>
</ul>
</details>

<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum chunk size in characters (only used when <code>batch=True</code>).</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tag</code>
            </td>
            <td>
                  <code><span title="str">str</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>HTML tag to split on. If None, auto-detects the best tag.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>batch</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True (default), groups multiple tags into a chunk, not exceeding <code>chunk_size</code>.
If False, returns one chunk per tag, ignoring chunk_size.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>to_markdown</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True, converts each chunk to Markdown using HtmlToMarkdown.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <blockquote>
<blockquote>
<blockquote>
<p>reader_output = ReaderOutput(text="<div>A</div><div>B</div>")
splitter = HTMLTagSplitter(tag="div", batch=False)
splitter.split(reader_output).chunks
['<html><body><div>A</div></body></html>', '<html><body><div>B</div></body></html>']
splitter = HTMLTagSplitter(tag="div", batch=True, chunk_size=100)
splitter.split(reader_output).chunks
['<html><body><div>A</div><div>B</div></body></html>']
splitter = HTMLTagSplitter(tag="div", batch=False, to_markdown=True)
splitter.split(reader_output).chunks
['A', 'B']</p>
</blockquote>
</blockquote>
</blockquote>
</details>

<p><span class="doc-section-title">Attributes:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.chunk_size">chunk_size</span></code></td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum chunk size.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.tag">tag</span></code></td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="str">str</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tag to split on.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.batch">batch</span></code></td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to group elements into chunks.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td><code><span title="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.to_markdown">to_markdown</span></code></td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Whether to convert each chunk to Markdown.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/html_tag_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">HTMLTagSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    HTMLTagSplitter splits HTML content into chunks based on a specified tag.</span>
<span class="sd">    Supports batching and optional Markdown conversion.</span>

<span class="sd">    Behavior:</span>
<span class="sd">      - When `tag` is specified (e.g., tag=&quot;div&quot;), finds all matching elements.</span>
<span class="sd">      - When `tag` is None, splits by the most frequent and shallowest tag.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum chunk size in characters (only used when `batch=True`).</span>
<span class="sd">        tag (str | None): HTML tag to split on. If None, auto-detects the best tag.</span>
<span class="sd">        batch (bool): If True (default), groups multiple tags into a chunk, not exceeding `chunk_size`.</span>
<span class="sd">            If False, returns one chunk per tag, ignoring chunk_size.</span>
<span class="sd">        to_markdown (bool): If True, converts each chunk to Markdown using HtmlToMarkdown.</span>

<span class="sd">    Example:</span>
<span class="sd">        &gt;&gt;&gt; reader_output = ReaderOutput(text=&quot;&lt;div&gt;A&lt;/div&gt;&lt;div&gt;B&lt;/div&gt;&quot;)</span>
<span class="sd">        &gt;&gt;&gt; splitter = HTMLTagSplitter(tag=&quot;div&quot;, batch=False)</span>
<span class="sd">        &gt;&gt;&gt; splitter.split(reader_output).chunks</span>
<span class="sd">        [&#39;&lt;html&gt;&lt;body&gt;&lt;div&gt;A&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#39;, &#39;&lt;html&gt;&lt;body&gt;&lt;div&gt;B&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; splitter = HTMLTagSplitter(tag=&quot;div&quot;, batch=True, chunk_size=100)</span>
<span class="sd">        &gt;&gt;&gt; splitter.split(reader_output).chunks</span>
<span class="sd">        [&#39;&lt;html&gt;&lt;body&gt;&lt;div&gt;A&lt;/div&gt;&lt;div&gt;B&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&#39;]</span>
<span class="sd">        &gt;&gt;&gt; splitter = HTMLTagSplitter(tag=&quot;div&quot;, batch=False, to_markdown=True)</span>
<span class="sd">        &gt;&gt;&gt; splitter.split(reader_output).chunks</span>
<span class="sd">        [&#39;A&#39;, &#39;B&#39;]</span>

<span class="sd">    Attributes:</span>
<span class="sd">        chunk_size (int): Maximum chunk size.</span>
<span class="sd">        tag (Optional[str]): Tag to split on.</span>
<span class="sd">        batch (bool): Whether to group elements into chunks.</span>
<span class="sd">        to_markdown (bool): Whether to convert each chunk to Markdown.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">batch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">to_markdown</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initialize HTMLTagSplitter.</span>

<span class="sd">        Args:</span>
<span class="sd">            chunk_size (int): Maximum chunk size, in characters (only for batching).</span>
<span class="sd">            tag (str | None): Tag to split on. If None, auto-detects.</span>
<span class="sd">            batch (bool): If True (default), groups tags up to `chunk_size`.</span>
<span class="sd">            to_markdown (bool): If True (default), convert each chunk to Markdown.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span> <span class="o">=</span> <span class="n">to_markdown</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits HTML using the specified tag and batching, with optional Markdown conversion.</span>

<span class="sd">        Semantics:</span>
<span class="sd">        - Tables:</span>
<span class="sd">            * batch=False -&gt; one chunk per requested element. If splitting by a row-level tag</span>
<span class="sd">                (e.g. &#39;tr&#39;), emit a mini-table per row: &lt;thead&gt; once + that row in &lt;tbody&gt;.</span>
<span class="sd">            * batch=True and chunk_size in (0, 1, None) -&gt; all tables in one chunk.</span>
<span class="sd">            * batch=True and chunk_size &gt; 1 -&gt; split each table into multiple chunks</span>
<span class="sd">                by batching &lt;tr&gt; rows (copying a &lt;thead&gt; into every chunk and</span>
<span class="sd">                skipping the header row from the body).</span>
<span class="sd">        - Non-table tags:</span>
<span class="sd">            * batch=False -&gt; one chunk per element.</span>
<span class="sd">            * batch=True and chunk_size in (0, 1, None) -&gt; all elements in one chunk.</span>
<span class="sd">            * batch=True and chunk_size &gt; 1 -&gt; batch by total HTML length.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output: ReaderOutput containing at least `text`.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">html</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reader_output</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
        <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
        <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_tag</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>

        <span class="c1"># Locate elements for the chosen tag.</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
            <span class="n">table_children</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;tbody&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">,</span> <span class="s2">&quot;td&quot;</span><span class="p">}</span>
            <span class="c1"># Only escalate to table when batching is enabled. For non-batch,</span>
            <span class="c1"># keep the exact tag so we can emit one chunk per element.</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">table_children</span><span class="p">:</span>
                <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
                <span class="n">parent_tables</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="n">table</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">table</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                        <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">table</span><span class="p">))</span>
                        <span class="n">parent_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parent_tables</span><span class="p">:</span>
                    <span class="n">elements</span> <span class="o">=</span> <span class="n">parent_tables</span>
                    <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;table&quot;</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># -------- helpers -------- #</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_doc_with_children</span><span class="p">(</span><span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Wrap a list of top-level nodes into &lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;.&quot;&quot;&quot;</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
            <span class="n">html_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>
            <span class="n">body_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
            <span class="n">html_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body_tag</span><span class="p">)</span>
            <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">html_tag</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                <span class="n">body_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_tag</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Return (header_thead, data_rows, header_row_src) where:</span>
<span class="sd">            - header_thead is a &lt;thead&gt; (deep-copied) or None</span>
<span class="sd">            - data_rows is a list of original &lt;tr&gt; nodes that are NOT header rows</span>
<span class="sd">            - header_row_src is the original &lt;tr&gt; used to synthesize &lt;thead&gt; (if any)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">header</span> <span class="o">=</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span>
            <span class="n">header_row_src</span> <span class="o">=</span> <span class="kc">None</span>

            <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">data_rows</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">data_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="n">data_rows</span><span class="p">,</span> <span class="kc">None</span>

            <span class="n">first_tr</span> <span class="o">=</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">)</span>
            <span class="n">header_thead</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">if</span> <span class="n">first_tr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
                <span class="n">thead</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span>
                <span class="n">thead</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">first_tr</span><span class="p">))</span>
                <span class="n">header_thead</span> <span class="o">=</span> <span class="n">thead</span>
                <span class="n">header_row_src</span> <span class="o">=</span> <span class="n">first_tr</span>

            <span class="n">data_rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">header_row_src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tr</span> <span class="ow">is</span> <span class="n">header_row_src</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">data_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">header_thead</span><span class="p">,</span> <span class="n">data_rows</span><span class="p">,</span> <span class="n">header_row_src</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">build_table_chunk</span><span class="p">(</span><span class="n">table_tag</span><span class="p">,</span> <span class="n">rows_subset</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Build a &lt;html&gt;&lt;body&gt;&lt;table&gt; chunk with:</span>
<span class="sd">            - original table attributes</span>
<span class="sd">            - a &lt;thead&gt; (original or synthesized)</span>
<span class="sd">            - a &lt;tbody&gt; containing rows_subset</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">header_thead</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_tag</span><span class="p">)</span>
            <span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
            <span class="n">html_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>
            <span class="n">body_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
            <span class="n">html_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body_tag</span><span class="p">)</span>
            <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">html_tag</span><span class="p">)</span>

            <span class="n">new_table</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">table_tag</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">header_thead</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">new_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">header_thead</span><span class="p">))</span>

            <span class="n">tbody</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;tbody&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows_subset</span><span class="p">:</span>
                <span class="n">tbody</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
            <span class="n">new_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tbody</span><span class="p">)</span>

            <span class="n">body_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_table</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

        <span class="c1"># -------- main chunking -------- #</span>

        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
            <span class="c1"># TABLES: custom batching</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">:</span>
                <span class="c1"># one chunk per table (full)</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">])</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="c1"># all tables together</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">elements</span><span class="p">)]</span> <span class="k">if</span> <span class="n">elements</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># batch rows within each table</span>
                <span class="k">for</span> <span class="n">table_el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="n">header_thead</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_el</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">table_el</span><span class="p">]))</span>
                        <span class="k">continue</span>

                    <span class="n">buf</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                        <span class="n">test_buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span>
                        <span class="n">test_html</span> <span class="o">=</span> <span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">test_buf</span><span class="p">)</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_html</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">and</span> <span class="n">buf</span><span class="p">:</span>
                            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
                            <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">buf</span> <span class="o">=</span> <span class="n">test_buf</span>
                    <span class="k">if</span> <span class="n">buf</span><span class="p">:</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># NON-TABLE (including table children when batch=False)</span>
            <span class="n">table_children</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;tbody&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">,</span> <span class="s2">&quot;td&quot;</span><span class="p">}</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">table_children</span><span class="p">:</span>
                    <span class="c1"># one chunk per row-like element, but keep header context</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                        <span class="n">table_el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">)</span>
                        <span class="k">if</span> <span class="ow">not</span> <span class="n">table_el</span><span class="p">:</span>
                            <span class="c1"># Fallback: wrap the element as-is</span>
                            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">]))</span>
                            <span class="k">continue</span>
                        <span class="c1"># skip header-only rows</span>
                        <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;tr&quot;</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">}:</span>
                            <span class="k">continue</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="p">[</span><span class="n">el</span><span class="p">]))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">]))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">elements</span><span class="p">)]</span> <span class="k">if</span> <span class="n">elements</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="n">test_buffer</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
                    <span class="n">test_chunk_str</span> <span class="o">=</span> <span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">test_buffer</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_chunk_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">and</span> <span class="n">buffer</span><span class="p">:</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
                        <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">buffer</span> <span class="o">=</span> <span class="n">test_buffer</span>
                <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">:</span>
            <span class="n">md</span> <span class="o">=</span> <span class="n">HtmlToMarkdown</span><span class="p">()</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>

        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;html_tag_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span>
                <span class="s2">&quot;batch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">,</span>
                <span class="s2">&quot;to_markdown&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">(),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_auto_tag</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">soup</span><span class="p">:</span> <span class="n">BeautifulSoup</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Auto-detect the most repeated tag with the highest (shallowest) level of hierarchy.</span>
<span class="sd">        If no repeated tags are found, return the first tag found in &lt;body&gt; or fallback to &#39;div&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>

        <span class="n">body</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">body</span><span class="p">:</span>
            <span class="k">return</span> <span class="s2">&quot;div&quot;</span>

        <span class="c1"># Traverse all tags in body, tracking tag: (count, min_depth)</span>
        <span class="n">tag_counter</span> <span class="o">=</span> <span class="n">Counter</span><span class="p">()</span>
        <span class="n">tag_min_depth</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="k">lambda</span><span class="p">:</span> <span class="nb">float</span><span class="p">(</span><span class="s2">&quot;inf&quot;</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">traverse</span><span class="p">(</span><span class="n">el</span><span class="p">,</span> <span class="n">depth</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">el</span><span class="o">.</span><span class="n">children</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="s2">&quot;name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
                    <span class="n">tag_counter</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="n">tag_min_depth</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">tag_min_depth</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">name</span><span class="p">],</span> <span class="n">depth</span><span class="p">)</span>
                    <span class="n">traverse</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">depth</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="n">traverse</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">tag_counter</span><span class="p">:</span>
            <span class="c1"># fallback to first tag</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">body</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">t</span><span class="o">.</span><span class="n">name</span>
            <span class="k">return</span> <span class="s2">&quot;div&quot;</span>

        <span class="c1"># Find tags with the maximum count</span>
        <span class="n">max_count</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">tag_counter</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="n">candidates</span> <span class="o">=</span> <span class="p">[</span><span class="n">t</span> <span class="k">for</span> <span class="n">t</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">tag_counter</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">cnt</span> <span class="o">==</span> <span class="n">max_count</span><span class="p">]</span>
        <span class="c1"># Of the most frequent, pick the one with the minimum depth (shallowest)</span>
        <span class="n">chosen</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">candidates</span><span class="p">,</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">t</span><span class="p">:</span> <span class="n">tag_min_depth</span><span class="p">[</span><span class="n">t</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">chosen</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">batch</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">to_markdown</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Initialize HTMLTagSplitter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum chunk size, in characters (only for batching).</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>tag</code>
            </td>
            <td>
                  <code><span title="str">str</span> | None</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Tag to split on. If None, auto-detects.</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>batch</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True (default), groups tags up to <code>chunk_size</code>.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>to_markdown</code>
            </td>
            <td>
                  <code><span title="bool">bool</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If True (default), convert each chunk to Markdown.</p>
              </div>
            </td>
            <td>
                  <code>True</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/html_tag_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">46</span>
<span class="normal">47</span>
<span class="normal">48</span>
<span class="normal">49</span>
<span class="normal">50</span>
<span class="normal">51</span>
<span class="normal">52</span>
<span class="normal">53</span>
<span class="normal">54</span>
<span class="normal">55</span>
<span class="normal">56</span>
<span class="normal">57</span>
<span class="normal">58</span>
<span class="normal">59</span>
<span class="normal">60</span>
<span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">tag</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">batch</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="n">to_markdown</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Initialize HTMLTagSplitter.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum chunk size, in characters (only for batching).</span>
<span class="sd">        tag (str | None): Tag to split on. If None, auto-detects.</span>
<span class="sd">        batch (bool): If True (default), groups tags up to `chunk_size`.</span>
<span class="sd">        to_markdown (bool): If True (default), convert each chunk to Markdown.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="o">=</span> <span class="n">tag</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">batch</span> <span class="o">=</span> <span class="n">batch</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span> <span class="o">=</span> <span class="n">to_markdown</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.html_tag_splitter.HTMLTagSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits HTML using the specified tag and batching, with optional Markdown conversion.</p>
<p>Semantics:
- Tables:
    * batch=False -&gt; one chunk per requested element. If splitting by a row-level tag
        (e.g. 'tr'), emit a mini-table per row: <thead> once + that row in <tbody>.
    * batch=True and chunk_size in (0, 1, None) -&gt; all tables in one chunk.
    * batch=True and chunk_size &gt; 1 -&gt; split each table into multiple chunks
        by batching <tr> rows (copying a <thead> into every chunk and
        skipping the header row from the body).
- Non-table tags:
    * batch=False -&gt; one chunk per element.
    * batch=True and chunk_size in (0, 1, None) -&gt; all elements in one chunk.
    * batch=True and chunk_size &gt; 1 -&gt; batch by total HTML length.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>ReaderOutput containing at least <code>text</code>.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>SplitterOutput</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/html_tag_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits HTML using the specified tag and batching, with optional Markdown conversion.</span>

<span class="sd">    Semantics:</span>
<span class="sd">    - Tables:</span>
<span class="sd">        * batch=False -&gt; one chunk per requested element. If splitting by a row-level tag</span>
<span class="sd">            (e.g. &#39;tr&#39;), emit a mini-table per row: &lt;thead&gt; once + that row in &lt;tbody&gt;.</span>
<span class="sd">        * batch=True and chunk_size in (0, 1, None) -&gt; all tables in one chunk.</span>
<span class="sd">        * batch=True and chunk_size &gt; 1 -&gt; split each table into multiple chunks</span>
<span class="sd">            by batching &lt;tr&gt; rows (copying a &lt;thead&gt; into every chunk and</span>
<span class="sd">            skipping the header row from the body).</span>
<span class="sd">    - Non-table tags:</span>
<span class="sd">        * batch=False -&gt; one chunk per element.</span>
<span class="sd">        * batch=True and chunk_size in (0, 1, None) -&gt; all elements in one chunk.</span>
<span class="sd">        * batch=True and chunk_size &gt; 1 -&gt; batch by total HTML length.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output: ReaderOutput containing at least `text`.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">html</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">reader_output</span><span class="p">,</span> <span class="s2">&quot;text&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span>
    <span class="n">soup</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
    <span class="n">tag</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_auto_tag</span><span class="p">(</span><span class="n">soup</span><span class="p">)</span>

    <span class="c1"># Locate elements for the chosen tag.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="n">soup</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="n">tag</span><span class="p">)</span>
        <span class="n">table_children</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;tbody&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">,</span> <span class="s2">&quot;td&quot;</span><span class="p">}</span>
        <span class="c1"># Only escalate to table when batching is enabled. For non-batch,</span>
        <span class="c1"># keep the exact tag so we can emit one chunk per element.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span> <span class="ow">and</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">table_children</span><span class="p">:</span>
            <span class="n">seen</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">parent_tables</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">table</span> <span class="ow">and</span> <span class="nb">id</span><span class="p">(</span><span class="n">table</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">seen</span><span class="p">:</span>
                    <span class="n">seen</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="nb">id</span><span class="p">(</span><span class="n">table</span><span class="p">))</span>
                    <span class="n">parent_tables</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">table</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">parent_tables</span><span class="p">:</span>
                <span class="n">elements</span> <span class="o">=</span> <span class="n">parent_tables</span>
                <span class="n">tag</span> <span class="o">=</span> <span class="s2">&quot;table&quot;</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="n">elements</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># -------- helpers -------- #</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_doc_with_children</span><span class="p">(</span><span class="n">children</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap a list of top-level nodes into &lt;html&gt;&lt;body&gt;&lt;/body&gt;&lt;/html&gt;.&quot;&quot;&quot;</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
        <span class="n">html_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>
        <span class="n">body_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
        <span class="n">html_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body_tag</span><span class="p">)</span>
        <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">html_tag</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
            <span class="n">body_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_tag</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Return (header_thead, data_rows, header_row_src) where:</span>
<span class="sd">        - header_thead is a &lt;thead&gt; (deep-copied) or None</span>
<span class="sd">        - data_rows is a list of original &lt;tr&gt; nodes that are NOT header rows</span>
<span class="sd">        - header_row_src is the original &lt;tr&gt; used to synthesize &lt;thead&gt; (if any)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span>
        <span class="n">header_row_src</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="n">header</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">data_rows</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">data_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">header</span><span class="p">),</span> <span class="n">data_rows</span><span class="p">,</span> <span class="kc">None</span>

        <span class="n">first_tr</span> <span class="o">=</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">)</span>
        <span class="n">header_thead</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">first_tr</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
            <span class="n">thead</span> <span class="o">=</span> <span class="n">tmp</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span>
            <span class="n">thead</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">first_tr</span><span class="p">))</span>
            <span class="n">header_thead</span> <span class="o">=</span> <span class="n">thead</span>
            <span class="n">header_row_src</span> <span class="o">=</span> <span class="n">first_tr</span>

        <span class="n">data_rows</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">tr</span> <span class="ow">in</span> <span class="n">table_tag</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s2">&quot;tr&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">header_row_src</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">tr</span> <span class="ow">is</span> <span class="n">header_row_src</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="n">tr</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">data_rows</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">header_thead</span><span class="p">,</span> <span class="n">data_rows</span><span class="p">,</span> <span class="n">header_row_src</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_table_chunk</span><span class="p">(</span><span class="n">table_tag</span><span class="p">,</span> <span class="n">rows_subset</span><span class="p">:</span> <span class="n">List</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Build a &lt;html&gt;&lt;body&gt;&lt;table&gt; chunk with:</span>
<span class="sd">        - original table attributes</span>
<span class="sd">        - a &lt;thead&gt; (original or synthesized)</span>
<span class="sd">        - a &lt;tbody&gt; containing rows_subset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">header_thead</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_tag</span><span class="p">)</span>
        <span class="n">doc</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="s2">&quot;html.parser&quot;</span><span class="p">)</span>
        <span class="n">html_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;html&quot;</span><span class="p">)</span>
        <span class="n">body_tag</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;body&quot;</span><span class="p">)</span>
        <span class="n">html_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">body_tag</span><span class="p">)</span>
        <span class="n">doc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">html_tag</span><span class="p">)</span>

        <span class="n">new_table</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">table_tag</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">header_thead</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">header_thead</span><span class="p">))</span>

        <span class="n">tbody</span> <span class="o">=</span> <span class="n">doc</span><span class="o">.</span><span class="n">new_tag</span><span class="p">(</span><span class="s2">&quot;tbody&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rows_subset</span><span class="p">:</span>
            <span class="n">tbody</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">copy</span><span class="o">.</span><span class="n">deepcopy</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>
        <span class="n">new_table</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tbody</span><span class="p">)</span>

        <span class="n">body_tag</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_table</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="n">doc</span><span class="p">)</span>

    <span class="c1"># -------- main chunking -------- #</span>

    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">if</span> <span class="n">tag</span> <span class="o">==</span> <span class="s2">&quot;table&quot;</span><span class="p">:</span>
        <span class="c1"># TABLES: custom batching</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">:</span>
            <span class="c1"># one chunk per table (full)</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">])</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">]</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># all tables together</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">elements</span><span class="p">)]</span> <span class="k">if</span> <span class="n">elements</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># batch rows within each table</span>
            <span class="k">for</span> <span class="n">table_el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="n">header_thead</span><span class="p">,</span> <span class="n">rows</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">extract_table_header_and_rows</span><span class="p">(</span><span class="n">table_el</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">table_el</span><span class="p">]))</span>
                    <span class="k">continue</span>

                <span class="n">buf</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                    <span class="n">test_buf</span> <span class="o">=</span> <span class="n">buf</span> <span class="o">+</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span>
                    <span class="n">test_html</span> <span class="o">=</span> <span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">test_buf</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_html</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">and</span> <span class="n">buf</span><span class="p">:</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>
                        <span class="n">buf</span> <span class="o">=</span> <span class="p">[</span><span class="n">row</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">buf</span> <span class="o">=</span> <span class="n">test_buf</span>
                <span class="k">if</span> <span class="n">buf</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="n">buf</span><span class="p">))</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># NON-TABLE (including table children when batch=False)</span>
        <span class="n">table_children</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;tbody&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">,</span> <span class="s2">&quot;td&quot;</span><span class="p">}</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">tag</span> <span class="ow">in</span> <span class="n">table_children</span><span class="p">:</span>
                <span class="c1"># one chunk per row-like element, but keep header context</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="n">table_el</span> <span class="o">=</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;table&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">table_el</span><span class="p">:</span>
                        <span class="c1"># Fallback: wrap the element as-is</span>
                        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">]))</span>
                        <span class="k">continue</span>
                    <span class="c1"># skip header-only rows</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;tr&quot;</span> <span class="ow">and</span> <span class="n">el</span><span class="o">.</span><span class="n">find_parent</span><span class="p">(</span><span class="s2">&quot;thead&quot;</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">{</span><span class="s2">&quot;thead&quot;</span><span class="p">,</span> <span class="s2">&quot;th&quot;</span><span class="p">}:</span>
                        <span class="k">continue</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_table_chunk</span><span class="p">(</span><span class="n">table_el</span><span class="p">,</span> <span class="p">[</span><span class="n">el</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">([</span><span class="n">el</span><span class="p">]))</span>

        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">elements</span><span class="p">)]</span> <span class="k">if</span> <span class="n">elements</span> <span class="k">else</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">buffer</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elements</span><span class="p">:</span>
                <span class="n">test_buffer</span> <span class="o">=</span> <span class="n">buffer</span> <span class="o">+</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="n">test_chunk_str</span> <span class="o">=</span> <span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">test_buffer</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_chunk_str</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="ow">and</span> <span class="n">buffer</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>
                    <span class="n">buffer</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">buffer</span> <span class="o">=</span> <span class="n">test_buffer</span>
            <span class="k">if</span> <span class="n">buffer</span><span class="p">:</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">build_doc_with_children</span><span class="p">(</span><span class="n">buffer</span><span class="p">))</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="p">]</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">:</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">HtmlToMarkdown</span><span class="p">()</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">md</span><span class="o">.</span><span class="n">convert</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">chunks</span><span class="p">]</span>

    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;html_tag_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="n">tag</span><span class="p">,</span>
            <span class="s2">&quot;batch&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">batch</span><span class="p">,</span>
            <span class="s2">&quot;to_markdown&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">(),</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="rowcolumnsplitter">RowColumnSplitter<a class="headerlink" href="#rowcolumnsplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.row_column_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter" class="doc doc-heading">
            <code>RowColumnSplitter</code>


<a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>RowColumnSplitter splits tabular data (such as CSV, TSV, Markdown tables, or JSON tables)
into smaller tables based on rows, columns, or by total character size while preserving row integrity.</p>
<p>This splitter supports several modes:</p>
<ul>
<li><strong>By rows</strong>: Split the table into chunks with a fixed number of rows, with optional overlapping
    rows between chunks.</li>
<li><strong>By columns</strong>: Split the table into chunks by columns, with optional overlapping columns between chunks.</li>
<li><strong>By chunk size</strong>: Split the table into markdown-formatted table chunks, where each chunk contains
    as many complete rows as fit under the specified character limit, optionally overlapping a fixed
    number of rows between chunks.</li>
</ul>
<p>This is useful for splitting large tabular files for downstream processing, LLM ingestion,
or display, while preserving semantic and structural integrity of the data.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of characters per chunk (when using character-based splitting).</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_rows</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of rows per chunk. Mutually exclusive with num_cols.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>num_cols</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of columns per chunk. Mutually exclusive with num_rows.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="typing.Union">Union</span>[<span title="int">int</span>, <span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of overlapping rows or columns between chunks.
If a float in (0,1), interpreted as a percentage of rows or columns. If integer, the number of
overlapping rows/columns. When chunking by character size, this refers to the number of overlapping
rows (not characters).</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>
        <p>Supported formats: CSV, TSV, TXT, Markdown table, JSON (tabular: list of dicts or dict of lists).</p>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/row_column_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span>
<span class="normal">330</span>
<span class="normal">331</span>
<span class="normal">332</span>
<span class="normal">333</span>
<span class="normal">334</span>
<span class="normal">335</span>
<span class="normal">336</span>
<span class="normal">337</span>
<span class="normal">338</span>
<span class="normal">339</span>
<span class="normal">340</span>
<span class="normal">341</span>
<span class="normal">342</span>
<span class="normal">343</span>
<span class="normal">344</span>
<span class="normal">345</span>
<span class="normal">346</span>
<span class="normal">347</span>
<span class="normal">348</span>
<span class="normal">349</span>
<span class="normal">350</span>
<span class="normal">351</span>
<span class="normal">352</span>
<span class="normal">353</span>
<span class="normal">354</span>
<span class="normal">355</span>
<span class="normal">356</span>
<span class="normal">357</span>
<span class="normal">358</span>
<span class="normal">359</span>
<span class="normal">360</span>
<span class="normal">361</span>
<span class="normal">362</span>
<span class="normal">363</span>
<span class="normal">364</span>
<span class="normal">365</span>
<span class="normal">366</span>
<span class="normal">367</span>
<span class="normal">368</span>
<span class="normal">369</span>
<span class="normal">370</span>
<span class="normal">371</span>
<span class="normal">372</span>
<span class="normal">373</span>
<span class="normal">374</span>
<span class="normal">375</span>
<span class="normal">376</span>
<span class="normal">377</span>
<span class="normal">378</span>
<span class="normal">379</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">RowColumnSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    RowColumnSplitter splits tabular data (such as CSV, TSV, Markdown tables, or JSON tables)</span>
<span class="sd">    into smaller tables based on rows, columns, or by total character size while preserving row integrity.</span>

<span class="sd">    This splitter supports several modes:</span>

<span class="sd">    - **By rows**: Split the table into chunks with a fixed number of rows, with optional overlapping</span>
<span class="sd">        rows between chunks.</span>
<span class="sd">    - **By columns**: Split the table into chunks by columns, with optional overlapping columns between chunks.</span>
<span class="sd">    - **By chunk size**: Split the table into markdown-formatted table chunks, where each chunk contains</span>
<span class="sd">        as many complete rows as fit under the specified character limit, optionally overlapping a fixed</span>
<span class="sd">        number of rows between chunks.</span>

<span class="sd">    This is useful for splitting large tabular files for downstream processing, LLM ingestion,</span>
<span class="sd">    or display, while preserving semantic and structural integrity of the data.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of characters per chunk (when using character-based splitting).</span>
<span class="sd">        num_rows (int): Number of rows per chunk. Mutually exclusive with num_cols.</span>
<span class="sd">        num_cols (int): Number of columns per chunk. Mutually exclusive with num_rows.</span>
<span class="sd">        chunk_overlap (Union[int, float]): Number of overlapping rows or columns between chunks.</span>
<span class="sd">            If a float in (0,1), interpreted as a percentage of rows or columns. If integer, the number of</span>
<span class="sd">            overlapping rows/columns. When chunking by character size, this refers to the number of overlapping</span>
<span class="sd">            rows (not characters).</span>

<span class="sd">    Supported formats: CSV, TSV, TXT, Markdown table, JSON (tabular: list of dicts or dict of lists).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">num_rows</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">num_cols</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">chunk_overlap</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">=</span> <span class="n">num_rows</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">=</span> <span class="n">num_cols</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

        <span class="k">if</span> <span class="n">num_rows</span> <span class="ow">and</span> <span class="n">num_cols</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;num_rows and num_cols are mutually exclusive&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span> <span class="ow">and</span> <span class="n">chunk_overlap</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap as float must be &lt; 1&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input tabular data into multiple markdown table chunks according to the specified</span>
<span class="sd">        chunking strategy. Each output chunk is a complete markdown table with header, and will never</span>
<span class="sd">        cut a row in half. The overlap is always applied in terms of full rows or columns.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary output from a Reader, containing at least:</span>
<span class="sd">                    - &#39;text&#39;: The tabular data as string.</span>
<span class="sd">                    - &#39;conversion_method&#39;: Format of the input (&#39;csv&#39;, &#39;tsv&#39;, &#39;markdown&#39;, &#39;json&#39;, etc.).</span>
<span class="sd">                    - Additional document metadata fields (optional).</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If both num_rows and num_cols are set.</span>
<span class="sd">            ValueError: If chunk_overlap as float is not in [0,1).</span>
<span class="sd">            ValueError: If chunk_size is too small to fit the header and at least one data row.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &#39;| id | name |\\n|----|------|\\n| 1  | A    |\\n| 2  | B    |\\n| 3  | C    |&#39;,</span>
<span class="sd">                conversion_method: &quot;markdown&quot;,</span>
<span class="sd">                document_name: &quot;table.md&quot;,</span>
<span class="sd">                document_path: &quot;/path/table.md&quot;,</span>
<span class="sd">            )</span>
<span class="sd">            splitter = RowColumnSplitter(chunk_size=80, chunk_overlap=20)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            for chunk in output[&quot;chunks&quot;]:</span>
<span class="sd">                print(&quot;\\n&quot; + str(chunk) + &quot;\\n&quot;)</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            | id   | name   |</span>
<span class="sd">            |------|--------|</span>
<span class="sd">            |  1   | A      |</span>
<span class="sd">            |  2   | B      |</span>

<span class="sd">            | id   | name   |</span>
<span class="sd">            |------|--------|</span>
<span class="sd">            |  2   | B      |</span>
<span class="sd">            |  3   | C      |</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Step 1. Parse the table depending on conversion_method</span>
        <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_tabular</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
        <span class="n">orig_method</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span>
        <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

        <span class="c1"># Step 2. Split logic</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">meta_per_chunk</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># If splitting strategy is by rows</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                    <span class="n">chunk_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_str</span><span class="p">(</span><span class="n">chunk_df</span><span class="p">,</span> <span class="n">orig_method</span><span class="p">)</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
                    <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="p">{</span><span class="s2">&quot;rows&quot;</span><span class="p">:</span> <span class="n">chunk_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;row&quot;</span><span class="p">}</span>
                    <span class="p">)</span>
        <span class="c1"># If splitting strategy is by columns</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>
            <span class="n">total_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span>
                <span class="n">total_cols</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="n">sel_cols</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">sel_cols</span><span class="p">:</span>
                    <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sel_cols</span><span class="p">]</span>
                    <span class="n">chunk_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_str</span><span class="p">(</span><span class="n">chunk_df</span><span class="p">,</span> <span class="n">orig_method</span><span class="p">,</span> <span class="n">colwise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
                    <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;cols&quot;</span><span class="p">:</span> <span class="n">sel_cols</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;column&quot;</span><span class="p">})</span>
        <span class="c1"># If splitting strategy is given by the chunk_size</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">header_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_markdown_header</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
            <span class="n">header_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_lines</span><span class="p">)</span>

            <span class="n">row_md_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_markdown_row</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))]</span>
            <span class="n">row_len_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">row_md_list</span><span class="p">]</span>  <span class="c1"># +1 for newline</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="n">header_length</span> <span class="o">+</span> <span class="n">row_len_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;chunk_size is too small to fit header and at least one row.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Compute overlapping and headers in markdown tables</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">meta_per_chunk</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_md_list</span><span class="p">)</span>
            <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
                <span class="n">curr_chunk</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">curr_len</span> <span class="o">=</span> <span class="n">header_length</span>
                <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
                <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">curr_len</span> <span class="o">+</span> <span class="n">row_len_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
                    <span class="n">curr_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_md_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                    <span class="n">curr_len</span> <span class="o">+=</span> <span class="n">row_len_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                    <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="n">rows_in_chunk</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
                <span class="n">chunk_str</span> <span class="o">=</span> <span class="n">header_lines</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_chunk</span><span class="p">)</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
                <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;rows&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)),</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char_row&quot;</span><span class="p">})</span>

                <span class="c1"># --- compute overlap AFTER we know rows_in_chunk ---</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                    <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rows_in_chunk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>

                <span class="c1"># make sure we dont loop forever</span>
                <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overlap_rows</span><span class="p">,</span> <span class="n">rows_in_chunk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">overlap_rows</span>

        <span class="c1"># Generate chunk_id</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;row_column_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;num_rows&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span>
                <span class="s2">&quot;num_cols&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;chunks&quot;</span><span class="p">:</span> <span class="n">meta_per_chunk</span><span class="p">},</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>

    <span class="c1"># Helper functions</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_get_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="nb">int</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the overlap value as an integer, based on the configured chunk_overlap.</span>

<span class="sd">        If chunk_overlap is a float in (0,1), computes the overlap as a percentage of `base`.</span>
<span class="sd">        If chunk_overlap is an integer, returns it directly.</span>

<span class="sd">        Args:</span>
<span class="sd">            base (int): The base number (rows or columns) to compute the overlap from.</span>
<span class="sd">        Returns:</span>
<span class="sd">            int: The overlap as an integer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">base</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_load_tabular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads and parses the input tabular data from a Reader output dictionary</span>
<span class="sd">        into a pandas DataFrame, based on its format.</span>

<span class="sd">        If the input is empty, returns an empty DataFrame.</span>
<span class="sd">        If the input is malformed (e.g., badly formatted markdown/CSV/TSV), a</span>
<span class="sd">        pandas.errors.ParserError is raised.</span>

<span class="sd">        Supports Markdown, CSV, TSV, TXT, and tabular JSON.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]): Dictionary containing the text and conversion_method.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: The loaded table as a DataFrame.</span>

<span class="sd">        Raises:</span>
<span class="sd">            pandas.errors.ParserError: If the input table is malformed and cannot be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="c1"># Return a void dataframe is a empty file is provided</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">text</span> <span class="ow">or</span> <span class="ow">not</span> <span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;markdown&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_markdown_table</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;csv&quot;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;txt&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;tsv&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">text</span><span class="p">),</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Try JSON</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">js</span> <span class="o">=</span> <span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">js</span><span class="p">,</span> <span class="nb">list</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="nb">isinstance</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="nb">dict</span><span class="p">)</span> <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">js</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">js</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">js</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>  <span class="c1"># e.g., {col: [vals]}</span>
                    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">js</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="c1"># Fallback: try CSV</span>
            <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span><span class="n">text</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_markdown_table</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">md</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses a markdown table string into a pandas DataFrame.</span>

<span class="sd">        Ignores non-table lines and trims markdown-specific formatting.</span>
<span class="sd">        Also handles the separator line (---) in the header.</span>

<span class="sd">        Args:</span>
<span class="sd">            md (str): The markdown table as a string.</span>

<span class="sd">        Returns:</span>
<span class="sd">            pd.DataFrame: Parsed table as a DataFrame.</span>

<span class="sd">        Raises:</span>
<span class="sd">            pandas.errors.ParserError: If the markdown table is malformed and cannot be parsed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Remove any lines not part of the table (e.g., text before/after)</span>
        <span class="n">table_lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">started</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">md</span><span class="o">.</span><span class="n">splitlines</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^\s*\|.*\|\s*$&quot;</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                <span class="n">started</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">table_lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
            <span class="k">elif</span> <span class="n">started</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">():</span>
                <span class="k">break</span>  <span class="c1"># stop at first blank line after table</span>
        <span class="n">table_md</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">table_lines</span><span class="p">)</span>
        <span class="n">table_io</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">(</span>
            <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span>
                <span class="sa">r</span><span class="s2">&quot;^\s*\|&quot;</span><span class="p">,</span>
                <span class="s2">&quot;&quot;</span><span class="p">,</span>
                <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\|\s*$&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="n">table_md</span><span class="p">,</span> <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">),</span>
                <span class="n">flags</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">MULTILINE</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">table_io</span><span class="p">,</span> <span class="n">sep</span><span class="o">=</span><span class="s2">&quot;|&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span>
                <span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">axis</span><span class="o">=</span><span class="s2">&quot;columns&quot;</span>
            <span class="p">)</span>
        <span class="k">except</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">ParserError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="c1"># Propagate the ParserError for your test to catch</span>
            <span class="k">raise</span> <span class="n">pd</span><span class="o">.</span><span class="n">errors</span><span class="o">.</span><span class="n">ParserError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Malformed markdown table: </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">df</span><span class="o">.</span><span class="n">empty</span> <span class="ow">and</span> <span class="nb">all</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;^-+$&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">df</span><span class="o">.</span><span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">reset_index</span><span class="p">(</span><span class="n">drop</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">df</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_to_str</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">df</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">colwise</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts a DataFrame chunk to a string for output,</span>
<span class="sd">        either as a markdown table, CSV, or a list of columns.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): DataFrame chunk to convert.</span>
<span class="sd">            method (str): Input file format (for output style).</span>
<span class="sd">            colwise (bool): If True, output as a list of columns (used in column chunking).</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The chunk as a formatted string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">colwise</span><span class="p">:</span>
            <span class="c1"># List of columns: output as a list of lists</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="s2">&quot;[&quot;</span>
                <span class="o">+</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>  <span class="c1"># noqa: W503</span>
                    <span class="p">[</span><span class="nb">str</span><span class="p">([</span><span class="n">col</span><span class="p">]</span> <span class="o">+</span> <span class="n">df</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span> <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="p">]</span>  <span class="c1"># noqa: W503</span>
                <span class="p">)</span>
                <span class="o">+</span> <span class="s2">&quot;]&quot;</span>  <span class="c1"># noqa: W503</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;markdown&quot;</span> <span class="ow">or</span> <span class="s2">&quot;md&quot;</span><span class="p">:</span>
            <span class="c1"># Use markdown table format</span>
            <span class="k">return</span> <span class="n">df</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Default to CSV format</span>
            <span class="n">output</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">StringIO</span><span class="p">()</span>
            <span class="n">df</span><span class="o">.</span><span class="n">to_csv</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_markdown_header</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the header and separator lines for a markdown table as a string.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): DataFrame representing the table.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: Markdown table header and separator (with trailing newline).</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">lines</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">lines</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_get_markdown_row</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">row_idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a single row from the DataFrame formatted as a markdown table row.</span>

<span class="sd">        Args:</span>
<span class="sd">            df (pd.DataFrame): DataFrame containing the table.</span>
<span class="sd">            row_idx (int): Index of the row to extract.</span>

<span class="sd">        Returns:</span>
<span class="sd">            str: The markdown-formatted row string.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[[</span><span class="n">row_idx</span><span class="p">]]</span>
        <span class="c1"># Get the full markdown output (with header),</span>
        <span class="c1"># extract only the last line (the data row)</span>
        <span class="n">md</span> <span class="o">=</span> <span class="n">row</span><span class="o">.</span><span class="n">to_markdown</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">md</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.row_column_splitter.RowColumnSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input tabular data into multiple markdown table chunks according to the specified
chunking strategy. Each output chunk is a complete markdown table with header, and will never
cut a row in half. The overlap is always applied in terms of full rows or columns.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="typing.Dict">Dict</span>[<span title="str">str</span>, <span title="typing.Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary output from a Reader, containing at least:
    - 'text': The tabular data as string.
    - 'conversion_method': Format of the input ('csv', 'tsv', 'markdown', 'json', etc.).
    - Additional document metadata fields (optional).</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If both num_rows and num_cols are set.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If chunk_overlap as float is not in [0,1).</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If chunk_size is too small to fit the header and at least one data row.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s1">&#39;| id | name |</span><span class="se">\n</span><span class="s1">|----|------|</span><span class="se">\n</span><span class="s1">| 1  | A    |</span><span class="se">\n</span><span class="s1">| 2  | B    |</span><span class="se">\n</span><span class="s1">| 3  | C    |&#39;</span><span class="p">,</span>
    <span class="n">conversion_method</span><span class="p">:</span> <span class="s2">&quot;markdown&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;table.md&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/path/table.md&quot;</span><span class="p">,</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">RowColumnSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">80</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">20</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="k">for</span> <span class="n">chunk</span> <span class="ow">in</span> <span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">]:</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="o">|</span> <span class="nb">id</span>   <span class="o">|</span> <span class="n">name</span>   <span class="o">|</span>
<span class="o">|------|--------|</span>
<span class="o">|</span>  <span class="mi">1</span>   <span class="o">|</span> <span class="n">A</span>      <span class="o">|</span>
<span class="o">|</span>  <span class="mi">2</span>   <span class="o">|</span> <span class="n">B</span>      <span class="o">|</span>

<span class="o">|</span> <span class="nb">id</span>   <span class="o">|</span> <span class="n">name</span>   <span class="o">|</span>
<span class="o">|------|--------|</span>
<span class="o">|</span>  <span class="mi">2</span>   <span class="o">|</span> <span class="n">B</span>      <span class="o">|</span>
<span class="o">|</span>  <span class="mi">3</span>   <span class="o">|</span> <span class="n">C</span>      <span class="o">|</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/row_column_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input tabular data into multiple markdown table chunks according to the specified</span>
<span class="sd">    chunking strategy. Each output chunk is a complete markdown table with header, and will never</span>
<span class="sd">    cut a row in half. The overlap is always applied in terms of full rows or columns.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary output from a Reader, containing at least:</span>
<span class="sd">                - &#39;text&#39;: The tabular data as string.</span>
<span class="sd">                - &#39;conversion_method&#39;: Format of the input (&#39;csv&#39;, &#39;tsv&#39;, &#39;markdown&#39;, &#39;json&#39;, etc.).</span>
<span class="sd">                - Additional document metadata fields (optional).</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If both num_rows and num_cols are set.</span>
<span class="sd">        ValueError: If chunk_overlap as float is not in [0,1).</span>
<span class="sd">        ValueError: If chunk_size is too small to fit the header and at least one data row.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &#39;| id | name |\\n|----|------|\\n| 1  | A    |\\n| 2  | B    |\\n| 3  | C    |&#39;,</span>
<span class="sd">            conversion_method: &quot;markdown&quot;,</span>
<span class="sd">            document_name: &quot;table.md&quot;,</span>
<span class="sd">            document_path: &quot;/path/table.md&quot;,</span>
<span class="sd">        )</span>
<span class="sd">        splitter = RowColumnSplitter(chunk_size=80, chunk_overlap=20)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        for chunk in output[&quot;chunks&quot;]:</span>
<span class="sd">            print(&quot;\\n&quot; + str(chunk) + &quot;\\n&quot;)</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        | id   | name   |</span>
<span class="sd">        |------|--------|</span>
<span class="sd">        |  1   | A      |</span>
<span class="sd">        |  2   | B      |</span>

<span class="sd">        | id   | name   |</span>
<span class="sd">        |------|--------|</span>
<span class="sd">        |  2   | B      |</span>
<span class="sd">        |  3   | C      |</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Step 1. Parse the table depending on conversion_method</span>
    <span class="n">df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_load_tabular</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
    <span class="n">orig_method</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span>
    <span class="n">col_names</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>

    <span class="c1"># Step 2. Split logic</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">meta_per_chunk</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="c1"># If splitting strategy is by rows</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">),</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">]</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">chunk_df</span><span class="o">.</span><span class="n">empty</span><span class="p">:</span>
                <span class="n">chunk_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_str</span><span class="p">(</span><span class="n">chunk_df</span><span class="p">,</span> <span class="n">orig_method</span><span class="p">)</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
                <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="p">{</span><span class="s2">&quot;rows&quot;</span><span class="p">:</span> <span class="n">chunk_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;row&quot;</span><span class="p">}</span>
                <span class="p">)</span>
    <span class="c1"># If splitting strategy is by columns</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">)</span>
        <span class="n">total_cols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col_names</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">total_cols</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">-</span> <span class="n">overlap</span> <span class="k">if</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span> <span class="o">-</span> <span class="n">overlap</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="k">else</span> <span class="mi">1</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="n">sel_cols</span> <span class="o">=</span> <span class="n">col_names</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">sel_cols</span><span class="p">:</span>
                <span class="n">chunk_df</span> <span class="o">=</span> <span class="n">df</span><span class="p">[</span><span class="n">sel_cols</span><span class="p">]</span>
                <span class="n">chunk_str</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_to_str</span><span class="p">(</span><span class="n">chunk_df</span><span class="p">,</span> <span class="n">orig_method</span><span class="p">,</span> <span class="n">colwise</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
                <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;cols&quot;</span><span class="p">:</span> <span class="n">sel_cols</span><span class="p">,</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;column&quot;</span><span class="p">})</span>
    <span class="c1"># If splitting strategy is given by the chunk_size</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">header_lines</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_markdown_header</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
        <span class="n">header_length</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">header_lines</span><span class="p">)</span>

        <span class="n">row_md_list</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_get_markdown_row</span><span class="p">(</span><span class="n">df</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">df</span><span class="p">))]</span>
        <span class="n">row_len_list</span> <span class="o">=</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">row_md_list</span><span class="p">]</span>  <span class="c1"># +1 for newline</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="n">header_length</span> <span class="o">+</span> <span class="n">row_len_list</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;chunk_size is too small to fit header and at least one row.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Compute overlapping and headers in markdown tables</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">meta_per_chunk</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">row_md_list</span><span class="p">)</span>
        <span class="n">overlap</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_overlap</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">:</span>
            <span class="n">curr_chunk</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">curr_len</span> <span class="o">=</span> <span class="n">header_length</span>
            <span class="n">j</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">while</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">n</span> <span class="ow">and</span> <span class="n">curr_len</span> <span class="o">+</span> <span class="n">row_len_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
                <span class="n">curr_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">row_md_list</span><span class="p">[</span><span class="n">j</span><span class="p">])</span>
                <span class="n">curr_len</span> <span class="o">+=</span> <span class="n">row_len_list</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">j</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="n">rows_in_chunk</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span>
            <span class="n">chunk_str</span> <span class="o">=</span> <span class="n">header_lines</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">curr_chunk</span><span class="p">)</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk_str</span><span class="p">)</span>
            <span class="n">meta_per_chunk</span><span class="o">.</span><span class="n">append</span><span class="p">({</span><span class="s2">&quot;rows&quot;</span><span class="p">:</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)),</span> <span class="s2">&quot;type&quot;</span><span class="p">:</span> <span class="s2">&quot;char_row&quot;</span><span class="p">})</span>

            <span class="c1"># --- compute overlap AFTER we know rows_in_chunk ---</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span> <span class="nb">float</span><span class="p">):</span>
                <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">rows_in_chunk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">)</span>

            <span class="c1"># make sure we dont loop forever</span>
            <span class="n">overlap_rows</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">overlap_rows</span><span class="p">,</span> <span class="n">rows_in_chunk</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">-</span> <span class="n">overlap_rows</span>

    <span class="c1"># Generate chunk_id</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;row_column_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;num_rows&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_rows</span><span class="p">,</span>
            <span class="s2">&quot;num_cols&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_cols</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;chunks&quot;</span><span class="p">:</span> <span class="n">meta_per_chunk</span><span class="p">},</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="codesplitter">CodeSplitter<a class="headerlink" href="#codesplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.code_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.code_splitter.CodeSplitter" class="doc doc-heading">
            <code>CodeSplitter</code>


<a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>CodeSplitter recursively splits source code into programmatically meaningful chunks
(functions, classes, methods, etc.) for the given programming language.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum chunk size, in characters.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>language</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Programming language (e.g., "python", "java", "kotlin", etc.)</p>
              </div>
            </td>
            <td>
                  <code>&#39;python&#39;</code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>Uses Langchain's RecursiveCharacterTextSplitter and its language-aware <code>from_language</code> method.</li>
<li>See Langchain docs: https://python.langchain.com/docs/how_to/code_splitter/</li>
</ul>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/code_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">CodeSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    CodeSplitter recursively splits source code into programmatically meaningful chunks</span>
<span class="sd">    (functions, classes, methods, etc.) for the given programming language.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum chunk size, in characters.</span>
<span class="sd">        language (str): Programming language (e.g., &quot;python&quot;, &quot;java&quot;, &quot;kotlin&quot;, etc.)</span>

<span class="sd">    Notes:</span>
<span class="sd">        - Uses Langchain&#39;s RecursiveCharacterTextSplitter and its language-aware `from_language` method.</span>
<span class="sd">        - See Langchain docs: https://python.langchain.com/docs/how_to/code_splitter/</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">language</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;python&quot;</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">language</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits code in `reader_output[&#39;text&#39;]` according to the syntax of the specified</span>
<span class="sd">        programming language, using function/class boundaries where possible.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): Object containing at least a &#39;text&#39; field,</span>
<span class="sd">                plus optional document metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If language is not supported.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import CodeSplitter</span>

<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;def foo():\\n    pass\\n\\nclass Bar:\\n    def baz(self):\\n        pass&quot;,</span>
<span class="sd">                document_name: &quot;example.py&quot;,</span>
<span class="sd">                document_path: &quot;/tmp/example.py&quot;</span>
<span class="sd">            )</span>
<span class="sd">            splitter = CodeSplitter(chunk_size=50, language=&quot;python&quot;)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output.chunks)</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&#39;def foo():\\n    pass\\n&#39;, &#39;class Bar:\\n    def baz(self):\\n        pass&#39;]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initialize variables</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

        <span class="c1"># Get Langchain language enum</span>
        <span class="n">lang_enum</span> <span class="o">=</span> <span class="n">get_langchain_language</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">)</span>

        <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="o">.</span><span class="n">from_language</span><span class="p">(</span>
            <span class="n">language</span><span class="o">=</span><span class="n">lang_enum</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span>
        <span class="p">)</span>
        <span class="n">texts</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">]</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="c1"># Return output</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;code_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="s2">&quot;language&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.code_splitter.CodeSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.code_splitter.CodeSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits code in <code>reader_output['text']</code> according to the syntax of the specified
programming language, using function/class boundaries where possible.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Object containing at least a 'text' field,
plus optional document metadata.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If language is not supported.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">CodeSplitter</span>

<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;def foo():</span><span class="se">\n</span><span class="s2">    pass</span><span class="se">\n\n</span><span class="s2">class Bar:</span><span class="se">\n</span><span class="s2">    def baz(self):</span><span class="se">\n</span><span class="s2">        pass&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;example.py&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;/tmp/example.py&quot;</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">CodeSplitter</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">50</span><span class="p">,</span> <span class="n">language</span><span class="o">=</span><span class="s2">&quot;python&quot;</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">chunks</span><span class="p">)</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s1">&#39;def foo():</span><span class="se">\n</span><span class="s1">    pass</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;class Bar:</span><span class="se">\n</span><span class="s1">    def baz(self):</span><span class="se">\n</span><span class="s1">        pass&#39;</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/code_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits code in `reader_output[&#39;text&#39;]` according to the syntax of the specified</span>
<span class="sd">    programming language, using function/class boundaries where possible.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (ReaderOutput): Object containing at least a &#39;text&#39; field,</span>
<span class="sd">            plus optional document metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If language is not supported.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import CodeSplitter</span>

<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;def foo():\\n    pass\\n\\nclass Bar:\\n    def baz(self):\\n        pass&quot;,</span>
<span class="sd">            document_name: &quot;example.py&quot;,</span>
<span class="sd">            document_path: &quot;/tmp/example.py&quot;</span>
<span class="sd">        )</span>
<span class="sd">        splitter = CodeSplitter(chunk_size=50, language=&quot;python&quot;)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output.chunks)</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&#39;def foo():\\n    pass\\n&#39;, &#39;class Bar:\\n    def baz(self):\\n        pass&#39;]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Initialize variables</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">chunk_size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span>

    <span class="c1"># Get Langchain language enum</span>
    <span class="n">lang_enum</span> <span class="o">=</span> <span class="n">get_langchain_language</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">)</span>

    <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="o">.</span><span class="n">from_language</span><span class="p">(</span>
        <span class="n">language</span><span class="o">=</span><span class="n">lang_enum</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span>
    <span class="p">)</span>
    <span class="n">texts</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">create_documents</span><span class="p">([</span><span class="n">text</span><span class="p">])</span>
    <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="n">doc</span><span class="o">.</span><span class="n">page_content</span> <span class="k">for</span> <span class="n">doc</span> <span class="ow">in</span> <span class="n">texts</span><span class="p">]</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="c1"># Return output</span>
    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;code_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="n">chunk_size</span><span class="p">,</span> <span class="s2">&quot;language&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>


<div class="doc doc-object doc-function">


<h5 id="splitter_mr.splitter.splitters.code_splitter.get_langchain_language" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">get_langchain_language</span><span class="p">(</span><span class="n">lang_str</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.code_splitter.get_langchain_language" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">

        <p>Map a string language name to Langchain Language enum.
Raises ValueError if not found.</p>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/code_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 7</span>
<span class="normal"> 8</span>
<span class="normal"> 9</span>
<span class="normal">10</span>
<span class="normal">11</span>
<span class="normal">12</span>
<span class="normal">13</span>
<span class="normal">14</span>
<span class="normal">15</span>
<span class="normal">16</span>
<span class="normal">17</span>
<span class="normal">18</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">get_langchain_language</span><span class="p">(</span><span class="n">lang_str</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Language</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Map a string language name to Langchain Language enum.</span>
<span class="sd">    Raises ValueError if not found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">lookup</span> <span class="o">=</span> <span class="p">{</span><span class="n">lang</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span> <span class="n">lang</span> <span class="k">for</span> <span class="n">lang</span> <span class="ow">in</span> <span class="n">Language</span><span class="p">}</span>
    <span class="n">key</span> <span class="o">=</span> <span class="n">lang_str</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">lookup</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported language &#39;</span><span class="si">{</span><span class="n">lang_str</span><span class="si">}</span><span class="s2">&#39;. Supported: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">lookup</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>
    <span class="k">return</span> <span class="n">lookup</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div><h3 id="tokensplitter">TokenSplitter<a class="headerlink" href="#tokensplitter" title="Permanent link">&para;</a></h3>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.token_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.token_splitter.TokenSplitter" class="doc doc-heading">
            <code>TokenSplitter</code>


<a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>TokenSplitter splits a given text into chunks based on token counts
derived from different tokenization models or libraries.</p>
<p>This splitter supports tokenization via <code>tiktoken</code> (OpenAI tokenizer),
<code>spacy</code> (spaCy tokenizer), and <code>nltk</code> (NLTK tokenizer). It allows splitting
text into chunks of a maximum number of tokens (<code>chunk_size</code>), using the
specified tokenizer model.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Maximum number of tokens per chunk.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>model_name</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Specifies the tokenizer and model in the format <code>tokenizer/model</code>. Supported tokenizers are:</p>
<ul>
<li><code>tiktoken/cl100k_base</code> (OpenAI tokenizer via tiktoken)</li>
<li><code>spacy/en_core_web_sm</code> (spaCy English model)</li>
<li><code>nltk/punkt_tab</code> (NLTK Punkt tokenizer variant)</li>
</ul>
              </div>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.constants.DEFAULT_TOKENIZER">DEFAULT_TOKENIZER</span></code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>language</code>
            </td>
            <td>
                  <code><span title="str">str</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Language code for NLTK tokenizer (default <code>"english"</code>).</p>
              </div>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.constants.DEFAULT_TOKEN_LANGUAGE">DEFAULT_TOKEN_LANGUAGE</span></code>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <p>More info about the splitting methods by Tokens for Langchain:
<a href="https://python.langchain.com/docs/how_to/split_by_token/">Langchain Docs</a>.</p>
</details>







              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/token_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">TokenSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    TokenSplitter splits a given text into chunks based on token counts</span>
<span class="sd">    derived from different tokenization models or libraries.</span>

<span class="sd">    This splitter supports tokenization via `tiktoken` (OpenAI tokenizer),</span>
<span class="sd">    `spacy` (spaCy tokenizer), and `nltk` (NLTK tokenizer). It allows splitting</span>
<span class="sd">    text into chunks of a maximum number of tokens (`chunk_size`), using the</span>
<span class="sd">    specified tokenizer model.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Maximum number of tokens per chunk.</span>
<span class="sd">        model_name (str): Specifies the tokenizer and model in the format `tokenizer/model`. Supported tokenizers are:</span>

<span class="sd">            - `tiktoken/cl100k_base` (OpenAI tokenizer via tiktoken)</span>
<span class="sd">            - `spacy/en_core_web_sm` (spaCy English model)</span>
<span class="sd">            - `nltk/punkt_tab` (NLTK Punkt tokenizer variant)</span>

<span class="sd">        language (str): Language code for NLTK tokenizer (default `&quot;english&quot;`).</span>

<span class="sd">    Notes:</span>
<span class="sd">        More info about the splitting methods by Tokens for Langchain:</span>
<span class="sd">        [Langchain Docs](https://python.langchain.com/docs/how_to/split_by_token/).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
        <span class="n">model_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_TOKENIZER</span><span class="p">,</span>
        <span class="n">language</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">DEFAULT_TOKEN_LANGUAGE</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="c1"># Use centralized defaults (already applied via signature) and keep on instance</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span> <span class="o">=</span> <span class="n">model_name</span> <span class="ow">or</span> <span class="n">DEFAULT_TOKENIZER</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">language</span> <span class="o">=</span> <span class="n">language</span> <span class="ow">or</span> <span class="n">DEFAULT_TOKEN_LANGUAGE</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">list_nltk_punkt_languages</span><span class="p">():</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a sorted list of available punkt models (languages) for NLTK.&quot;&quot;&quot;</span>
        <span class="n">models</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
            <span class="n">punkt_dir</span> <span class="o">=</span> <span class="n">base</span> <span class="o">/</span> <span class="s2">&quot;tokenizers&quot;</span> <span class="o">/</span> <span class="s2">&quot;punkt&quot;</span>
            <span class="k">if</span> <span class="n">punkt_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="n">models</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">stem</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">punkt_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.pickle&quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parse_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Parse `tokenizer/model` and validate the format.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;model_name must be in the format &#39;tokenizer/model&#39;, &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;e.g. &#39;</span><span class="si">{</span><span class="n">DEFAULT_TOKENIZER</span><span class="si">}</span><span class="s2">&#39;.&quot;</span>
            <span class="p">)</span>
        <span class="n">tokenizer</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">tokenizer</span><span class="p">,</span> <span class="n">model</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text from `reader_output` into token-based chunks using</span>
<span class="sd">        the specified tokenizer.</span>

<span class="sd">        Depending on `model_name`, the splitter chooses the appropriate tokenizer:</span>

<span class="sd">        - For `tiktoken`, uses `RecursiveCharacterTextSplitter` with tiktoken encoding.</span>
<span class="sd">            e.g.: `tiktoken/cl100k_base`.</span>
<span class="sd">        - For `spacy`, uses `SpacyTextSplitter` with the specified spaCy pipeline.</span>
<span class="sd">            e.g., `spacy/en_core_web_sm`.</span>
<span class="sd">        - For `nltk`, uses `NLTKTextSplitter` with the specified language tokenizer.</span>
<span class="sd">            e.g., `nltk/punkt_tab`.</span>

<span class="sd">        Automatically downloads spaCy and NLTK models if missing.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (Dict[str, Any]):</span>
<span class="sd">                Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata,</span>
<span class="sd">                such as &#39;document_name&#39;, &#39;document_path&#39;, &#39;document_id&#39;, etc.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">        Raises:</span>
<span class="sd">            RuntimeError: If a spaCy model specified in `model_name` is not available.</span>
<span class="sd">            ValueError: If an unsupported tokenizer is specified in `model_name`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="n">tokenizer</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_model</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;tiktoken&quot;</span><span class="p">:</span>
            <span class="c1"># Validate against installed tiktoken encodings; hint with our common defaults</span>
            <span class="n">available_models</span> <span class="o">=</span> <span class="n">tiktoken</span><span class="o">.</span><span class="n">list_encoding_names</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_models</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;tiktoken encoding &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39; is not available. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Available encodings include (subset): </span><span class="si">{</span><span class="n">TIKTOKEN_DEFAULTS</span><span class="si">}</span><span class="s2">. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Full list from tiktoken: </span><span class="si">{</span><span class="n">available_models</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>
            <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="o">.</span><span class="n">from_tiktoken_encoder</span><span class="p">(</span>
                <span class="n">encoding_name</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;spacy&quot;</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">spacy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
                <span class="c1"># Try to download; we surface our recommended list in the error if it fails</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">spacy</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;spaCy model &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39; is not available for download. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;Common models include: </span><span class="si">{</span><span class="n">SPACY_DEFAULTS</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
            <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="n">MAX_SAFE_LENGTH</span> <span class="o">=</span> <span class="mi">1_000_000</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">&gt;</span> <span class="n">MAX_SAFE_LENGTH</span><span class="p">:</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                    <span class="s2">&quot;Too many characters: the v2.x parser and NER models require roughly &quot;</span>
                    <span class="s2">&quot;1GB of temporary memory per 100,000 characters in the input&quot;</span><span class="p">,</span>
                    <span class="ne">UserWarning</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="n">splitter</span> <span class="o">=</span> <span class="n">SpacyTextSplitter</span><span class="p">(</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">max_length</span><span class="o">=</span><span class="n">MAX_SAFE_LENGTH</span><span class="p">,</span>
                <span class="n">pipeline</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">elif</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;nltk&quot;</span><span class="p">:</span>
            <span class="c1"># Ensure punkt language is present; download our specified default model if missing</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tokenizers/punkt/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="si">}</span><span class="s2">.pickle&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
                <span class="c1"># Use constants instead of hard-coded &#39;punkt_tab&#39;</span>
                <span class="n">nltk</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">NLTK_DEFAULTS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">splitter</span> <span class="o">=</span> <span class="n">NLTKTextSplitter</span><span class="p">(</span>
                <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Unsupported tokenizer &#39;</span><span class="si">{</span><span class="n">tokenizer</span><span class="si">}</span><span class="s2">&#39;. Supported tokenizers: </span><span class="si">{</span><span class="n">SUPPORTED_TOKENIZERS</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="n">chunks</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;token_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;model_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span>  <span class="c1"># keeps centralized default visible</span>
                <span class="s2">&quot;language&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span>  <span class="c1"># keeps centralized default visible</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.token_splitter.TokenSplitter.list_nltk_punkt_languages" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">list_nltk_punkt_languages</span><span class="p">()</span></code>

  <span class="doc doc-labels">
      <small class="doc doc-label doc-label-staticmethod"><code>staticmethod</code></small>
  </span>

<a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.list_nltk_punkt_languages" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Return a sorted list of available punkt models (languages) for NLTK.</p>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/token_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">61</span>
<span class="normal">62</span>
<span class="normal">63</span>
<span class="normal">64</span>
<span class="normal">65</span>
<span class="normal">66</span>
<span class="normal">67</span>
<span class="normal">68</span>
<span class="normal">69</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="nd">@staticmethod</span>
<span class="k">def</span><span class="w"> </span><span class="nf">list_nltk_punkt_languages</span><span class="p">():</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Return a sorted list of available punkt models (languages) for NLTK.&quot;&quot;&quot;</span>
    <span class="n">models</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">base</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">path</span><span class="p">):</span>
        <span class="n">punkt_dir</span> <span class="o">=</span> <span class="n">base</span> <span class="o">/</span> <span class="s2">&quot;tokenizers&quot;</span> <span class="o">/</span> <span class="s2">&quot;punkt&quot;</span>
        <span class="k">if</span> <span class="n">punkt_dir</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
            <span class="n">models</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">f</span><span class="o">.</span><span class="n">stem</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">punkt_dir</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="s2">&quot;*.pickle&quot;</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">models</span><span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.token_splitter.TokenSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.token_splitter.TokenSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text from <code>reader_output</code> into token-based chunks using
the specified tokenizer.</p>
<p>Depending on <code>model_name</code>, the splitter chooses the appropriate tokenizer:</p>
<ul>
<li>For <code>tiktoken</code>, uses <code>RecursiveCharacterTextSplitter</code> with tiktoken encoding.
    e.g.: <code>tiktoken/cl100k_base</code>.</li>
<li>For <code>spacy</code>, uses <code>SpacyTextSplitter</code> with the specified spaCy pipeline.
    e.g., <code>spacy/en_core_web_sm</code>.</li>
<li>For <code>nltk</code>, uses <code>NLTKTextSplitter</code> with the specified language tokenizer.
    e.g., <code>nltk/punkt_tab</code>.</li>
</ul>
<p>Automatically downloads spaCy and NLTK models if missing.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><span title="Dict">Dict</span>[<span title="str">str</span>, <span title="Any">Any</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dictionary containing at least a 'text' key (str) and optional document metadata,
such as 'document_name', 'document_path', 'document_id', etc.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Dataclass defining the output structure for all splitters.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="RuntimeError">RuntimeError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If a spaCy model specified in <code>model_name</code> is not available.</p>
              </div>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If an unsupported tokenizer is specified in <code>model_name</code>.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/token_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text from `reader_output` into token-based chunks using</span>
<span class="sd">    the specified tokenizer.</span>

<span class="sd">    Depending on `model_name`, the splitter chooses the appropriate tokenizer:</span>

<span class="sd">    - For `tiktoken`, uses `RecursiveCharacterTextSplitter` with tiktoken encoding.</span>
<span class="sd">        e.g.: `tiktoken/cl100k_base`.</span>
<span class="sd">    - For `spacy`, uses `SpacyTextSplitter` with the specified spaCy pipeline.</span>
<span class="sd">        e.g., `spacy/en_core_web_sm`.</span>
<span class="sd">    - For `nltk`, uses `NLTKTextSplitter` with the specified language tokenizer.</span>
<span class="sd">        e.g., `nltk/punkt_tab`.</span>

<span class="sd">    Automatically downloads spaCy and NLTK models if missing.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (Dict[str, Any]):</span>
<span class="sd">            Dictionary containing at least a &#39;text&#39; key (str) and optional document metadata,</span>
<span class="sd">            such as &#39;document_name&#39;, &#39;document_path&#39;, &#39;document_id&#39;, etc.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Dataclass defining the output structure for all splitters.</span>

<span class="sd">    Raises:</span>
<span class="sd">        RuntimeError: If a spaCy model specified in `model_name` is not available.</span>
<span class="sd">        ValueError: If an unsupported tokenizer is specified in `model_name`.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="n">tokenizer</span><span class="p">,</span> <span class="n">model</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parse_model</span><span class="p">()</span>

    <span class="k">if</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;tiktoken&quot;</span><span class="p">:</span>
        <span class="c1"># Validate against installed tiktoken encodings; hint with our common defaults</span>
        <span class="n">available_models</span> <span class="o">=</span> <span class="n">tiktoken</span><span class="o">.</span><span class="n">list_encoding_names</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">model</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">available_models</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;tiktoken encoding &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39; is not available. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Available encodings include (subset): </span><span class="si">{</span><span class="n">TIKTOKEN_DEFAULTS</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Full list from tiktoken: </span><span class="si">{</span><span class="n">available_models</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">RecursiveCharacterTextSplitter</span><span class="o">.</span><span class="n">from_tiktoken_encoder</span><span class="p">(</span>
            <span class="n">encoding_name</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;spacy&quot;</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">spacy</span><span class="o">.</span><span class="n">util</span><span class="o">.</span><span class="n">is_package</span><span class="p">(</span><span class="n">model</span><span class="p">):</span>
            <span class="c1"># Try to download; we surface our recommended list in the error if it fails</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">spacy</span><span class="o">.</span><span class="n">cli</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;spaCy model &#39;</span><span class="si">{</span><span class="n">model</span><span class="si">}</span><span class="s2">&#39; is not available for download. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Common models include: </span><span class="si">{</span><span class="n">SPACY_DEFAULTS</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="n">spacy</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">model</span><span class="p">)</span>
        <span class="n">MAX_SAFE_LENGTH</span> <span class="o">=</span> <span class="mi">1_000_000</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">&gt;</span> <span class="n">MAX_SAFE_LENGTH</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s2">&quot;Too many characters: the v2.x parser and NER models require roughly &quot;</span>
                <span class="s2">&quot;1GB of temporary memory per 100,000 characters in the input&quot;</span><span class="p">,</span>
                <span class="ne">UserWarning</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">SpacyTextSplitter</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">max_length</span><span class="o">=</span><span class="n">MAX_SAFE_LENGTH</span><span class="p">,</span>
            <span class="n">pipeline</span><span class="o">=</span><span class="n">model</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">elif</span> <span class="n">tokenizer</span> <span class="o">==</span> <span class="s2">&quot;nltk&quot;</span><span class="p">:</span>
        <span class="c1"># Ensure punkt language is present; download our specified default model if missing</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">nltk</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tokenizers/punkt/</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="si">}</span><span class="s2">.pickle&quot;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">LookupError</span><span class="p">:</span>
            <span class="c1"># Use constants instead of hard-coded &#39;punkt_tab&#39;</span>
            <span class="n">nltk</span><span class="o">.</span><span class="n">download</span><span class="p">(</span><span class="n">NLTK_DEFAULTS</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">splitter</span> <span class="o">=</span> <span class="n">NLTKTextSplitter</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">language</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span>
        <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unsupported tokenizer &#39;</span><span class="si">{</span><span class="n">tokenizer</span><span class="si">}</span><span class="s2">&#39;. Supported tokenizers: </span><span class="si">{</span><span class="n">SUPPORTED_TOKENIZERS</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="n">chunks</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split_text</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;token_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;model_name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">model_name</span><span class="p">,</span>  <span class="c1"># keeps centralized default visible</span>
            <span class="s2">&quot;language&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">language</span><span class="p">,</span>  <span class="c1"># keeps centralized default visible</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="pagedsplitter">PagedSplitter<a class="headerlink" href="#pagedsplitter" title="Permanent link">&para;</a></h3>
<p>Splits text by pages for documents that have page structure. Each chunk contains a specified number of pages, with optional word overlap.</p>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.paged_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.paged_splitter.PagedSplitter" class="doc doc-heading">
            <code>PagedSplitter</code>


<a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.base_splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>Splits a multi-page document into page-based or multi-page chunks using a placeholder marker.</p>
<p>Supports overlap in characters between consecutive chunks.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of pages per chunk.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of overlapping characters to include from the end of the previous chunk.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If chunk_size is less than 1.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/paged_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">  7</span>
<span class="normal">  8</span>
<span class="normal">  9</span>
<span class="normal"> 10</span>
<span class="normal"> 11</span>
<span class="normal"> 12</span>
<span class="normal"> 13</span>
<span class="normal"> 14</span>
<span class="normal"> 15</span>
<span class="normal"> 16</span>
<span class="normal"> 17</span>
<span class="normal"> 18</span>
<span class="normal"> 19</span>
<span class="normal"> 20</span>
<span class="normal"> 21</span>
<span class="normal"> 22</span>
<span class="normal"> 23</span>
<span class="normal"> 24</span>
<span class="normal"> 25</span>
<span class="normal"> 26</span>
<span class="normal"> 27</span>
<span class="normal"> 28</span>
<span class="normal"> 29</span>
<span class="normal"> 30</span>
<span class="normal"> 31</span>
<span class="normal"> 32</span>
<span class="normal"> 33</span>
<span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PagedSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits a multi-page document into page-based or multi-page chunks using a placeholder marker.</span>

<span class="sd">    Supports overlap in characters between consecutive chunks.</span>

<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Number of pages per chunk.</span>
<span class="sd">        chunk_overlap (int): Number of overlapping characters to include from the end of the previous chunk.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If chunk_size is less than 1.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Args:</span>
<span class="sd">            chunk_size (int): Number of pages per chunk.</span>
<span class="sd">            chunk_overlap (int): Number of overlapping characters to include from the end of the previous chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_size must be 1&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be 0&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits the input text into chunks using the page_placeholder in the ReaderOutput.</span>
<span class="sd">        Optionally adds character overlap between chunks.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): The output from a reader containing text and metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: The result with chunks and related metadata.</span>

<span class="sd">        Raises:</span>
<span class="sd">            ValueError: If the reader_output does not contain a valid page_placeholder.</span>

<span class="sd">        Example:</span>
<span class="sd">            ```python</span>
<span class="sd">            from splitter_mr.splitter import PagedSplitter</span>

<span class="sd">            reader_output = ReaderOutput(</span>
<span class="sd">                text: &quot;&lt;!-- page --&gt; Page 1 &lt;!-- page --&gt; This is the page 2.&quot;,</span>
<span class="sd">                document_name: &quot;test.md&quot;,</span>
<span class="sd">                document_path: &quot;tmp/test.md&quot;,</span>
<span class="sd">                page_placeholder: &quot;&lt;!-- page --&gt;&quot;,</span>
<span class="sd">                ...</span>
<span class="sd">            )</span>
<span class="sd">            splitter = PagedSplitter(chunk_size = 1)</span>
<span class="sd">            output = splitter.split(reader_output)</span>
<span class="sd">            print(output[&quot;chunks&quot;])</span>
<span class="sd">            ```</span>
<span class="sd">            ```python</span>
<span class="sd">            [&quot; Page 1 &quot;, &quot; This is the page 2.&quot;]</span>
<span class="sd">            ```</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">page_placeholder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">page_placeholder</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">page_placeholder</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;The specified file does not contain page placeholders. &quot;</span>
                <span class="s2">&quot;Please, use a compatible file extension (pdf, docx, xlsx, pptx) &quot;</span>
                <span class="s2">&quot;or read the file using any BaseReader by pages and try again&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Split the document into pages using the placeholder.</span>
        <span class="n">pages</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
            <span class="n">page</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># Normalize spacing</span>
            <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">page_placeholder</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">page</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
        <span class="p">]</span>

        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">):</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
                <span class="c1"># Add character overlap from previous chunk</span>
                <span class="n">overlap_text</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="p">:]</span>
                <span class="n">chunk</span> <span class="o">=</span> <span class="n">overlap_text</span> <span class="o">+</span> <span class="n">chunk</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

        <span class="c1"># Generate chunk_id and append metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

        <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;paged_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">



<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of pages per chunk.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_overlap</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Number of overlapping characters to include from the end of the previous chunk.</p>
              </div>
            </td>
            <td>
                  <code>0</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/paged_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">21</span>
<span class="normal">22</span>
<span class="normal">23</span>
<span class="normal">24</span>
<span class="normal">25</span>
<span class="normal">26</span>
<span class="normal">27</span>
<span class="normal">28</span>
<span class="normal">29</span>
<span class="normal">30</span>
<span class="normal">31</span>
<span class="normal">32</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        chunk_size (int): Number of pages per chunk.</span>
<span class="sd">        chunk_overlap (int): Number of overlapping characters to include from the end of the previous chunk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">chunk_size</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_size must be 1&quot;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">chunk_overlap</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;chunk_overlap must be 0&quot;</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="n">chunk_size</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">=</span> <span class="n">chunk_overlap</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.paged_splitter.PagedSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Splits the input text into chunks using the page_placeholder in the ReaderOutput.
Optionally adds character overlap between chunks.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The output from a reader containing text and metadata.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The result with chunks and related metadata.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<p><span class="doc-section-title">Raises:</span></p>
    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                  <code><span title="ValueError">ValueError</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If the reader_output does not contain a valid page_placeholder.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="example" open>
  <summary>Example</summary>
  <p><div class="highlight"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">splitter_mr.splitter</span><span class="w"> </span><span class="kn">import</span> <span class="n">PagedSplitter</span>

<span class="n">reader_output</span> <span class="o">=</span> <span class="n">ReaderOutput</span><span class="p">(</span>
    <span class="n">text</span><span class="p">:</span> <span class="s2">&quot;&lt;!-- page --&gt; Page 1 &lt;!-- page --&gt; This is the page 2.&quot;</span><span class="p">,</span>
    <span class="n">document_name</span><span class="p">:</span> <span class="s2">&quot;test.md&quot;</span><span class="p">,</span>
    <span class="n">document_path</span><span class="p">:</span> <span class="s2">&quot;tmp/test.md&quot;</span><span class="p">,</span>
    <span class="n">page_placeholder</span><span class="p">:</span> <span class="s2">&quot;&lt;!-- page --&gt;&quot;</span><span class="p">,</span>
    <span class="o">...</span>
<span class="p">)</span>
<span class="n">splitter</span> <span class="o">=</span> <span class="n">PagedSplitter</span><span class="p">(</span><span class="n">chunk_size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">output</span> <span class="o">=</span> <span class="n">splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">output</span><span class="p">[</span><span class="s2">&quot;chunks&quot;</span><span class="p">])</span>
</code></pre></div>
<div class="highlight"><pre><span></span><code><span class="p">[</span><span class="s2">&quot; Page 1 &quot;</span><span class="p">,</span> <span class="s2">&quot; This is the page 2.&quot;</span><span class="p">]</span>
</code></pre></div></p>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/paged_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 34</span>
<span class="normal"> 35</span>
<span class="normal"> 36</span>
<span class="normal"> 37</span>
<span class="normal"> 38</span>
<span class="normal"> 39</span>
<span class="normal"> 40</span>
<span class="normal"> 41</span>
<span class="normal"> 42</span>
<span class="normal"> 43</span>
<span class="normal"> 44</span>
<span class="normal"> 45</span>
<span class="normal"> 46</span>
<span class="normal"> 47</span>
<span class="normal"> 48</span>
<span class="normal"> 49</span>
<span class="normal"> 50</span>
<span class="normal"> 51</span>
<span class="normal"> 52</span>
<span class="normal"> 53</span>
<span class="normal"> 54</span>
<span class="normal"> 55</span>
<span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Splits the input text into chunks using the page_placeholder in the ReaderOutput.</span>
<span class="sd">    Optionally adds character overlap between chunks.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (ReaderOutput): The output from a reader containing text and metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: The result with chunks and related metadata.</span>

<span class="sd">    Raises:</span>
<span class="sd">        ValueError: If the reader_output does not contain a valid page_placeholder.</span>

<span class="sd">    Example:</span>
<span class="sd">        ```python</span>
<span class="sd">        from splitter_mr.splitter import PagedSplitter</span>

<span class="sd">        reader_output = ReaderOutput(</span>
<span class="sd">            text: &quot;&lt;!-- page --&gt; Page 1 &lt;!-- page --&gt; This is the page 2.&quot;,</span>
<span class="sd">            document_name: &quot;test.md&quot;,</span>
<span class="sd">            document_path: &quot;tmp/test.md&quot;,</span>
<span class="sd">            page_placeholder: &quot;&lt;!-- page --&gt;&quot;,</span>
<span class="sd">            ...</span>
<span class="sd">        )</span>
<span class="sd">        splitter = PagedSplitter(chunk_size = 1)</span>
<span class="sd">        output = splitter.split(reader_output)</span>
<span class="sd">        print(output[&quot;chunks&quot;])</span>
<span class="sd">        ```</span>
<span class="sd">        ```python</span>
<span class="sd">        [&quot; Page 1 &quot;, &quot; This is the page 2.&quot;]</span>
<span class="sd">        ```</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">page_placeholder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">page_placeholder</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">bool</span><span class="p">(</span><span class="n">page_placeholder</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="s2">&quot;The specified file does not contain page placeholders. &quot;</span>
            <span class="s2">&quot;Please, use a compatible file extension (pdf, docx, xlsx, pptx) &quot;</span>
            <span class="s2">&quot;or read the file using any BaseReader by pages and try again&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Split the document into pages using the placeholder.</span>
    <span class="n">pages</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span>
        <span class="n">page</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>  <span class="c1"># Normalize spacing</span>
        <span class="k">for</span> <span class="n">page</span> <span class="ow">in</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">page_placeholder</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">page</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="p">]</span>

    <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">pages</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">):</span>
        <span class="n">chunk</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">pages</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="c1"># Add character overlap from previous chunk</span>
            <span class="n">overlap_text</span> <span class="o">=</span> <span class="n">chunks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">][</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span> <span class="p">:]</span>
            <span class="n">chunk</span> <span class="o">=</span> <span class="n">overlap_text</span> <span class="o">+</span> <span class="n">chunk</span>
        <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">chunk</span><span class="p">)</span>

    <span class="c1"># Generate chunk_id and append metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>

    <span class="n">output</span> <span class="o">=</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;paged_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;chunk_overlap&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_overlap</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="n">output</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div><h3 id="semanticsplitter">SemanticSplitter<a class="headerlink" href="#semanticsplitter" title="Permanent link">&para;</a></h3>
<p>Splits text into chunks based on semantic similarity, using an embedding model and a max tokens parameter. Useful for meaningful semantic groupings.</p>


<div class="doc doc-object doc-module">



<a id="splitter_mr.splitter.splitters.semantic_splitter"></a>
    <div class="doc doc-contents first">










  <div class="doc doc-children">









<div class="doc doc-object doc-class">



<h5 id="splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter" class="doc doc-heading">
            <code>SemanticSplitter</code>


<a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter" class="headerlink" title="Permanent link">&para;</a></h5>


    <div class="doc doc-contents ">
            <p class="doc doc-class-bases">
              Bases: <code><a class="autorefs autorefs-internal" title="BaseSplitter (splitter_mr.splitter.BaseSplitter)" href="#splitter_mr.splitter.base_splitter.BaseSplitter">BaseSplitter</a></code></p>


        <p>Split text into semantically coherent chunks using embedding similarity.</p>
<p><strong>Pipeline:</strong></p>
<ul>
<li>Split text into sentences via <code>SentenceSplitter</code> (one sentence chunks).</li>
<li>Build a sliding window around each sentence (<code>buffer_size</code>).</li>
<li>Embed each window with <code>BaseEmbedding</code> (batched).</li>
<li>Compute cosine <em>distances</em> between consecutive windows (1 - cosine_sim).</li>
<li>Pick breakpoints using a thresholding strategy, or aim for <code>number_of_chunks</code>.</li>
<li>Join sentences between breakpoints; enforce minimum size via <code>chunk_size</code>.</li>
</ul>








              <details class="quote">
                <summary>Source code in <code>src/splitter_mr/splitter/splitters/semantic_splitter.py</code></summary>
                <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 56</span>
<span class="normal"> 57</span>
<span class="normal"> 58</span>
<span class="normal"> 59</span>
<span class="normal"> 60</span>
<span class="normal"> 61</span>
<span class="normal"> 62</span>
<span class="normal"> 63</span>
<span class="normal"> 64</span>
<span class="normal"> 65</span>
<span class="normal"> 66</span>
<span class="normal"> 67</span>
<span class="normal"> 68</span>
<span class="normal"> 69</span>
<span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span>
<span class="normal">108</span>
<span class="normal">109</span>
<span class="normal">110</span>
<span class="normal">111</span>
<span class="normal">112</span>
<span class="normal">113</span>
<span class="normal">114</span>
<span class="normal">115</span>
<span class="normal">116</span>
<span class="normal">117</span>
<span class="normal">118</span>
<span class="normal">119</span>
<span class="normal">120</span>
<span class="normal">121</span>
<span class="normal">122</span>
<span class="normal">123</span>
<span class="normal">124</span>
<span class="normal">125</span>
<span class="normal">126</span>
<span class="normal">127</span>
<span class="normal">128</span>
<span class="normal">129</span>
<span class="normal">130</span>
<span class="normal">131</span>
<span class="normal">132</span>
<span class="normal">133</span>
<span class="normal">134</span>
<span class="normal">135</span>
<span class="normal">136</span>
<span class="normal">137</span>
<span class="normal">138</span>
<span class="normal">139</span>
<span class="normal">140</span>
<span class="normal">141</span>
<span class="normal">142</span>
<span class="normal">143</span>
<span class="normal">144</span>
<span class="normal">145</span>
<span class="normal">146</span>
<span class="normal">147</span>
<span class="normal">148</span>
<span class="normal">149</span>
<span class="normal">150</span>
<span class="normal">151</span>
<span class="normal">152</span>
<span class="normal">153</span>
<span class="normal">154</span>
<span class="normal">155</span>
<span class="normal">156</span>
<span class="normal">157</span>
<span class="normal">158</span>
<span class="normal">159</span>
<span class="normal">160</span>
<span class="normal">161</span>
<span class="normal">162</span>
<span class="normal">163</span>
<span class="normal">164</span>
<span class="normal">165</span>
<span class="normal">166</span>
<span class="normal">167</span>
<span class="normal">168</span>
<span class="normal">169</span>
<span class="normal">170</span>
<span class="normal">171</span>
<span class="normal">172</span>
<span class="normal">173</span>
<span class="normal">174</span>
<span class="normal">175</span>
<span class="normal">176</span>
<span class="normal">177</span>
<span class="normal">178</span>
<span class="normal">179</span>
<span class="normal">180</span>
<span class="normal">181</span>
<span class="normal">182</span>
<span class="normal">183</span>
<span class="normal">184</span>
<span class="normal">185</span>
<span class="normal">186</span>
<span class="normal">187</span>
<span class="normal">188</span>
<span class="normal">189</span>
<span class="normal">190</span>
<span class="normal">191</span>
<span class="normal">192</span>
<span class="normal">193</span>
<span class="normal">194</span>
<span class="normal">195</span>
<span class="normal">196</span>
<span class="normal">197</span>
<span class="normal">198</span>
<span class="normal">199</span>
<span class="normal">200</span>
<span class="normal">201</span>
<span class="normal">202</span>
<span class="normal">203</span>
<span class="normal">204</span>
<span class="normal">205</span>
<span class="normal">206</span>
<span class="normal">207</span>
<span class="normal">208</span>
<span class="normal">209</span>
<span class="normal">210</span>
<span class="normal">211</span>
<span class="normal">212</span>
<span class="normal">213</span>
<span class="normal">214</span>
<span class="normal">215</span>
<span class="normal">216</span>
<span class="normal">217</span>
<span class="normal">218</span>
<span class="normal">219</span>
<span class="normal">220</span>
<span class="normal">221</span>
<span class="normal">222</span>
<span class="normal">223</span>
<span class="normal">224</span>
<span class="normal">225</span>
<span class="normal">226</span>
<span class="normal">227</span>
<span class="normal">228</span>
<span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SemanticSplitter</span><span class="p">(</span><span class="n">BaseSplitter</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split text into semantically coherent chunks using embedding similarity.</span>

<span class="sd">    **Pipeline:**</span>

<span class="sd">    - Split text into sentences via `SentenceSplitter` (one sentence chunks).</span>
<span class="sd">    - Build a sliding window around each sentence (`buffer_size`).</span>
<span class="sd">    - Embed each window with `BaseEmbedding` (batched).</span>
<span class="sd">    - Compute cosine *distances* between consecutive windows (1 - cosine_sim).</span>
<span class="sd">    - Pick breakpoints using a thresholding strategy, or aim for `number_of_chunks`.</span>
<span class="sd">    - Join sentences between breakpoints; enforce minimum size via `chunk_size`.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">embedding</span><span class="p">:</span> <span class="n">BaseEmbedding</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">breakpoint_threshold_type</span><span class="p">:</span> <span class="n">BreakpointThresholdType</span> <span class="o">=</span> <span class="s2">&quot;percentile&quot;</span><span class="p">,</span>
        <span class="n">breakpoint_threshold_amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">number_of_chunks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize the semantic splitter.</span>

<span class="sd">        Args:</span>
<span class="sd">            embedding (BaseEmbedding): Embedding backend.</span>
<span class="sd">            buffer_size (int): Neighbor window size around each sentence.</span>
<span class="sd">            breakpoint_threshold_type (BreakpointThresholdType): Threshold strategy:</span>
<span class="sd">                &quot;percentile&quot; | &quot;standard_deviation&quot; | &quot;interquartile&quot; | &quot;gradient&quot;.</span>
<span class="sd">            breakpoint_threshold_amount (Optional[float]): Threshold parameter. If None,</span>
<span class="sd">                uses sensible defaults per strategy (e.g., 95th percentile).</span>
<span class="sd">            number_of_chunks (Optional[int]): If set, pick a threshold that</span>
<span class="sd">                approximately yields this number of chunks (inverse percentile).</span>
<span class="sd">            chunk_size (int): **Minimum** characters required to emit a chunk.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
            <span class="n">BreakpointThresholdType</span><span class="p">,</span> <span class="n">breakpoint_threshold_type</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">DEFAULT_BREAKPOINTS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">breakpoint_threshold_amount</span> <span class="ow">is</span> <span class="kc">None</span>
            <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">breakpoint_threshold_amount</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span> <span class="o">=</span> <span class="n">number_of_chunks</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sentence_splitter</span> <span class="o">=</span> <span class="n">SentenceSplitter</span><span class="p">(</span>
            <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">]</span>
        <span class="p">)</span>

    <span class="c1"># ---------- Helpers ----------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_split_into_sentences</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the input text into sentences using `SentenceSplitter` (no overlap).</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): The document to split.</span>

<span class="sd">        Returns:</span>
<span class="sd">            List[str]: List of sentences preserving punctuation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sent_out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sentence_splitter</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sent_out</span><span class="o">.</span><span class="n">chunks</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_sentence_distances</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">single_sentences</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Embed sentence windows (batch) and compute consecutive cosine distances.</span>

<span class="sd">        Args:</span>
<span class="sd">            single_sentences (List[str]): Sentences in order.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[List[float], List[Dict[str, Any]]]:</span>
<span class="sd">                - distances between consecutive windows (len = n-1)</span>
<span class="sd">                - sentence dicts enriched with combined text and embeddings</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Prepare sentence dicts and combine with buffer</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">{</span><span class="s2">&quot;sentence&quot;</span><span class="p">:</span> <span class="n">s</span><span class="p">,</span> <span class="s2">&quot;index&quot;</span><span class="p">:</span> <span class="n">i</span><span class="p">}</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">single_sentences</span><span class="p">)</span>
        <span class="p">]</span>
        <span class="n">sentences</span> <span class="o">=</span> <span class="n">_combine_sentences</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">)</span>

        <span class="c1"># Batch embed all combined sentences</span>
        <span class="n">windows</span> <span class="o">=</span> <span class="p">[</span><span class="n">item</span><span class="p">[</span><span class="s2">&quot;combined_sentence&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">sentences</span><span class="p">]</span>
        <span class="n">embeddings</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="o">.</span><span class="n">embed_documents</span><span class="p">(</span><span class="n">windows</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">item</span><span class="p">,</span> <span class="n">emb</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">sentences</span><span class="p">,</span> <span class="n">embeddings</span><span class="p">):</span>
            <span class="n">item</span><span class="p">[</span><span class="s2">&quot;combined_sentence_embedding&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">emb</span>

        <span class="c1"># Distances (1 - cosine similarity) between consecutive windows</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">[],</span> <span class="n">sentences</span>

        <span class="n">distances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">_cosine_similaritynp</span><span class="p">(</span>
                <span class="n">sentences</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;combined_sentence_embedding&quot;</span><span class="p">],</span>
                <span class="n">sentences</span><span class="p">[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">][</span><span class="s2">&quot;combined_sentence_embedding&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">sim</span>
            <span class="n">distances</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="n">sentences</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s2">&quot;distance_to_next&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">dist</span>

        <span class="k">return</span> <span class="n">distances</span><span class="p">,</span> <span class="n">sentences</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_threshold_from_clusters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Estimate a percentile threshold to reach `number_of_chunks`.</span>

<span class="sd">        Maps desired chunks x[1, len(distances)] to percentile y[100, 0].</span>

<span class="sd">        Args:</span>
<span class="sd">            distances (List[float]): Consecutive distances.</span>

<span class="sd">        Returns:</span>
<span class="sd">            float: Threshold value as a percentile over `distances`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)),</span> <span class="mf">0.0</span>
        <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="mf">100.0</span>
        <span class="n">x</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span><span class="p">),</span> <span class="n">x1</span><span class="p">),</span> <span class="n">x2</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">y1</span> <span class="o">+</span> <span class="p">((</span><span class="n">y2</span> <span class="o">-</span> <span class="n">y1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">x2</span> <span class="o">-</span> <span class="n">x1</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">x</span> <span class="o">-</span> <span class="n">x1</span><span class="p">)</span> <span class="k">if</span> <span class="n">x2</span> <span class="o">!=</span> <span class="n">x1</span> <span class="k">else</span> <span class="n">y2</span>
        <span class="n">y</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">clip</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">100.0</span><span class="p">))</span>
        <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">if</span> <span class="n">distances</span> <span class="k">else</span> <span class="mf">0.0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_calculate_breakpoint_threshold</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">distances</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">float</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compute the breakpoint threshold and reference array per selected strategy.</span>

<span class="sd">        Args:</span>
<span class="sd">            distances (List[float]): Consecutive distances between windows.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Tuple[float, List[float]]: (threshold, reference_array)</span>
<span class="sd">                If strategy == &quot;gradient&quot;, reference_array is the gradient;</span>
<span class="sd">                otherwise it&#39;s `distances`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">distances</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;percentile&quot;</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span><span class="p">)),</span>
                <span class="n">distances</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;standard_deviation&quot;</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="n">sd</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">mu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">*</span> <span class="n">sd</span><span class="p">,</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;interquartile&quot;</span><span class="p">:</span>
            <span class="n">q1</span><span class="p">,</span> <span class="n">q3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="p">[</span><span class="mf">25.0</span><span class="p">,</span> <span class="mf">75.0</span><span class="p">])</span>
            <span class="n">iqr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">q3</span> <span class="o">-</span> <span class="n">q1</span><span class="p">)</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">distances</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">mu</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">*</span> <span class="n">iqr</span><span class="p">,</span> <span class="n">distances</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span><span class="p">:</span>
            <span class="n">grads</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">gradient</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
            <span class="n">thr</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">grads</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">thr</span><span class="p">,</span> <span class="n">grads</span>  <span class="c1"># use gradient array as the reference</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Unexpected breakpoint_threshold_type: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="c1"># ---------- Public API ----------</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Split the document text into semantically coherent chunks.</span>

<span class="sd">        Args:</span>
<span class="sd">            reader_output (ReaderOutput): The document text &amp; metadata.</span>

<span class="sd">        Returns:</span>
<span class="sd">            SplitterOutput: Chunks, IDs, metadata, and splitter configuration.</span>

<span class="sd">        Notes:</span>
<span class="sd">            - With 1 sentence (or 2 in gradient mode), returns the text/sentences as-is.</span>
<span class="sd">            - Chunks shorter than `chunk_size` (minimum) are skipped and merged forward.</span>
<span class="sd">            - `chunk_size` behaves as the *minimum* chunk size in this splitter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
        <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No text has been provided&quot;</span><span class="p">)</span>

        <span class="n">amt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">)</span>
            <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">amt</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>  <span class="c1"># noqa: W503</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">=</span> <span class="n">amt</span> <span class="o">*</span> <span class="mf">100.0</span>

        <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_into_sentences</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>

        <span class="c1"># Edge cases where thresholds aren&#39;t meaningful</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">sentences</span> <span class="k">if</span> <span class="n">sentences</span> <span class="k">else</span> <span class="p">[</span><span class="n">text</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="n">sentences</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">distances</span><span class="p">,</span> <span class="n">sentence_dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_sentence_distances</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">distances</span><span class="p">:</span>
                <span class="c1"># Pick top (k-1) distances as breakpoints</span>
                <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span><span class="p">)</span>
                <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)))</span>  <span class="c1"># number of cuts to make</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">indices_above</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># single chunk</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># indices of the m largest distances (breaks), sorted in ascending order</span>
                    <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">))[</span><span class="o">-</span><span class="n">m</span><span class="p">:]</span>
                    <span class="n">indices_above</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">threshold</span><span class="p">,</span> <span class="n">ref_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_breakpoint_threshold</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
                <span class="n">indices_above</span> <span class="o">=</span> <span class="p">[</span>
                    <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_array</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">threshold</span>
                <span class="p">]</span>

            <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices_above</span><span class="p">:</span>
                <span class="n">end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># inclusive slice end</span>
                <span class="n">candidate</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sentence&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sentence_dicts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
                    <span class="c1"># too small: keep accumulating (do NOT move start_idx)</span>
                    <span class="k">continue</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
                <span class="n">start_idx</span> <span class="o">=</span> <span class="n">end</span>

            <span class="c1"># Tail (always emit whatever remains)</span>
            <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence_dicts</span><span class="p">):</span>
                <span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sentence&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sentence_dicts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:]</span>
                <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">tail</span><span class="p">:</span>
                    <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
                <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span>

        <span class="c1"># IDs &amp; metadata</span>
        <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>
        <span class="n">model_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="s2">&quot;model_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
            <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
            <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
            <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
            <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
            <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
            <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
            <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
            <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
            <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;semantic_splitter&quot;</span><span class="p">,</span>
            <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
                <span class="s2">&quot;buffer_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span>
                <span class="s2">&quot;breakpoint_threshold_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span><span class="p">,</span>
                <span class="s2">&quot;breakpoint_threshold_amount&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span><span class="p">,</span>
                <span class="s2">&quot;number_of_chunks&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span><span class="p">,</span>
                <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
                <span class="s2">&quot;model_name&quot;</span><span class="p">:</span> <span class="n">model_name</span><span class="p">,</span>
            <span class="p">},</span>
            <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
        <span class="p">)</span>
</code></pre></div></td></tr></table></div>
              </details>



  <div class="doc doc-children">










<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.__init__" class="doc doc-heading">
            <code class="highlight language-python"><span class="fm">__init__</span><span class="p">(</span><span class="n">embedding</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">buffer_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">breakpoint_threshold_type</span><span class="o">=</span><span class="s1">&#39;percentile&#39;</span><span class="p">,</span> <span class="n">breakpoint_threshold_amount</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">number_of_chunks</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1000</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.__init__" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Initialize the semantic splitter.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>embedding</code>
            </td>
            <td>
                  <code><span title="splitter_mr.embedding.BaseEmbedding">BaseEmbedding</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Embedding backend.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>buffer_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Neighbor window size around each sentence.</p>
              </div>
            </td>
            <td>
                  <code>1</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>breakpoint_threshold_type</code>
            </td>
            <td>
                  <code><span title="splitter_mr.schema.BreakpointThresholdType">BreakpointThresholdType</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Threshold strategy:
"percentile" | "standard_deviation" | "interquartile" | "gradient".</p>
              </div>
            </td>
            <td>
                  <code>&#39;percentile&#39;</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>breakpoint_threshold_amount</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="float">float</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Threshold parameter. If None,
uses sensible defaults per strategy (e.g., 95th percentile).</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>number_of_chunks</code>
            </td>
            <td>
                  <code><span title="typing.Optional">Optional</span>[<span title="int">int</span>]</code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>If set, pick a threshold that
approximately yields this number of chunks (inverse percentile).</p>
              </div>
            </td>
            <td>
                  <code>None</code>
            </td>
          </tr>
          <tr class="doc-section-item">
            <td>
                <code>chunk_size</code>
            </td>
            <td>
                  <code><span title="int">int</span></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p><strong>Minimum</strong> characters required to emit a chunk.</p>
              </div>
            </td>
            <td>
                  <code>1000</code>
            </td>
          </tr>
      </tbody>
    </table>


            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/semantic_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal"> 70</span>
<span class="normal"> 71</span>
<span class="normal"> 72</span>
<span class="normal"> 73</span>
<span class="normal"> 74</span>
<span class="normal"> 75</span>
<span class="normal"> 76</span>
<span class="normal"> 77</span>
<span class="normal"> 78</span>
<span class="normal"> 79</span>
<span class="normal"> 80</span>
<span class="normal"> 81</span>
<span class="normal"> 82</span>
<span class="normal"> 83</span>
<span class="normal"> 84</span>
<span class="normal"> 85</span>
<span class="normal"> 86</span>
<span class="normal"> 87</span>
<span class="normal"> 88</span>
<span class="normal"> 89</span>
<span class="normal"> 90</span>
<span class="normal"> 91</span>
<span class="normal"> 92</span>
<span class="normal"> 93</span>
<span class="normal"> 94</span>
<span class="normal"> 95</span>
<span class="normal"> 96</span>
<span class="normal"> 97</span>
<span class="normal"> 98</span>
<span class="normal"> 99</span>
<span class="normal">100</span>
<span class="normal">101</span>
<span class="normal">102</span>
<span class="normal">103</span>
<span class="normal">104</span>
<span class="normal">105</span>
<span class="normal">106</span>
<span class="normal">107</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
    <span class="bp">self</span><span class="p">,</span>
    <span class="n">embedding</span><span class="p">:</span> <span class="n">BaseEmbedding</span><span class="p">,</span>
    <span class="o">*</span><span class="p">,</span>
    <span class="n">buffer_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="n">breakpoint_threshold_type</span><span class="p">:</span> <span class="n">BreakpointThresholdType</span> <span class="o">=</span> <span class="s2">&quot;percentile&quot;</span><span class="p">,</span>
    <span class="n">breakpoint_threshold_amount</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">number_of_chunks</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="n">chunk_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Initialize the semantic splitter.</span>

<span class="sd">    Args:</span>
<span class="sd">        embedding (BaseEmbedding): Embedding backend.</span>
<span class="sd">        buffer_size (int): Neighbor window size around each sentence.</span>
<span class="sd">        breakpoint_threshold_type (BreakpointThresholdType): Threshold strategy:</span>
<span class="sd">            &quot;percentile&quot; | &quot;standard_deviation&quot; | &quot;interquartile&quot; | &quot;gradient&quot;.</span>
<span class="sd">        breakpoint_threshold_amount (Optional[float]): Threshold parameter. If None,</span>
<span class="sd">            uses sensible defaults per strategy (e.g., 95th percentile).</span>
<span class="sd">        number_of_chunks (Optional[int]): If set, pick a threshold that</span>
<span class="sd">            approximately yields this number of chunks (inverse percentile).</span>
<span class="sd">        chunk_size (int): **Minimum** characters required to emit a chunk.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">chunk_size</span><span class="o">=</span><span class="n">chunk_size</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">embedding</span> <span class="o">=</span> <span class="n">embedding</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">buffer_size</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span>
        <span class="n">BreakpointThresholdType</span><span class="p">,</span> <span class="n">breakpoint_threshold_type</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">DEFAULT_BREAKPOINTS</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">breakpoint_threshold_amount</span> <span class="ow">is</span> <span class="kc">None</span>
        <span class="k">else</span> <span class="nb">float</span><span class="p">(</span><span class="n">breakpoint_threshold_amount</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span> <span class="o">=</span> <span class="n">number_of_chunks</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">_sentence_splitter</span> <span class="o">=</span> <span class="n">SentenceSplitter</span><span class="p">(</span>
        <span class="n">chunk_size</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">chunk_overlap</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">separators</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;.&quot;</span><span class="p">,</span> <span class="s2">&quot;!&quot;</span><span class="p">,</span> <span class="s2">&quot;?&quot;</span><span class="p">]</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>

<div class="doc doc-object doc-function">


<h6 id="splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.split" class="doc doc-heading">
            <code class="highlight language-python"><span class="n">split</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span></code>

<a href="#splitter_mr.splitter.splitters.semantic_splitter.SemanticSplitter.split" class="headerlink" title="Permanent link">&para;</a></h6>


    <div class="doc doc-contents ">

        <p>Split the document text into semantically coherent chunks.</p>


<p><span class="doc-section-title">Parameters:</span></p>
    <table>
      <thead>
        <tr>
          <th>Name</th>
          <th>Type</th>
          <th>Description</th>
          <th>Default</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
            <td>
                <code>reader_output</code>
            </td>
            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.ReaderOutput" href="../reader/#splitter_mr.schema.models.ReaderOutput">ReaderOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>The document text &amp; metadata.</p>
              </div>
            </td>
            <td>
                <em>required</em>
            </td>
          </tr>
      </tbody>
    </table>


    <p><span class="doc-section-title">Returns:</span></p>
    <table>
      <thead>
        <tr>
<th>Name</th>          <th>Type</th>
          <th>Description</th>
        </tr>
      </thead>
      <tbody>
          <tr class="doc-section-item">
<td><code>SplitterOutput</code></td>            <td>
                  <code><a class="autorefs autorefs-internal" title="splitter_mr.schema.SplitterOutput" href="#splitter_mr.schema.models.SplitterOutput">SplitterOutput</a></code>
            </td>
            <td>
              <div class="doc-md-description">
                <p>Chunks, IDs, metadata, and splitter configuration.</p>
              </div>
            </td>
          </tr>
      </tbody>
    </table>


<details class="notes" open>
  <summary>Notes</summary>
  <ul>
<li>With 1 sentence (or 2 in gradient mode), returns the text/sentences as-is.</li>
<li>Chunks shorter than <code>chunk_size</code> (minimum) are skipped and merged forward.</li>
<li><code>chunk_size</code> behaves as the <em>minimum</em> chunk size in this splitter.</li>
</ul>
</details>

            <details class="quote">
              <summary>Source code in <code>src/splitter_mr/splitter/splitters/semantic_splitter.py</code></summary>
              <div class="highlight"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre><span></span><span class="normal">229</span>
<span class="normal">230</span>
<span class="normal">231</span>
<span class="normal">232</span>
<span class="normal">233</span>
<span class="normal">234</span>
<span class="normal">235</span>
<span class="normal">236</span>
<span class="normal">237</span>
<span class="normal">238</span>
<span class="normal">239</span>
<span class="normal">240</span>
<span class="normal">241</span>
<span class="normal">242</span>
<span class="normal">243</span>
<span class="normal">244</span>
<span class="normal">245</span>
<span class="normal">246</span>
<span class="normal">247</span>
<span class="normal">248</span>
<span class="normal">249</span>
<span class="normal">250</span>
<span class="normal">251</span>
<span class="normal">252</span>
<span class="normal">253</span>
<span class="normal">254</span>
<span class="normal">255</span>
<span class="normal">256</span>
<span class="normal">257</span>
<span class="normal">258</span>
<span class="normal">259</span>
<span class="normal">260</span>
<span class="normal">261</span>
<span class="normal">262</span>
<span class="normal">263</span>
<span class="normal">264</span>
<span class="normal">265</span>
<span class="normal">266</span>
<span class="normal">267</span>
<span class="normal">268</span>
<span class="normal">269</span>
<span class="normal">270</span>
<span class="normal">271</span>
<span class="normal">272</span>
<span class="normal">273</span>
<span class="normal">274</span>
<span class="normal">275</span>
<span class="normal">276</span>
<span class="normal">277</span>
<span class="normal">278</span>
<span class="normal">279</span>
<span class="normal">280</span>
<span class="normal">281</span>
<span class="normal">282</span>
<span class="normal">283</span>
<span class="normal">284</span>
<span class="normal">285</span>
<span class="normal">286</span>
<span class="normal">287</span>
<span class="normal">288</span>
<span class="normal">289</span>
<span class="normal">290</span>
<span class="normal">291</span>
<span class="normal">292</span>
<span class="normal">293</span>
<span class="normal">294</span>
<span class="normal">295</span>
<span class="normal">296</span>
<span class="normal">297</span>
<span class="normal">298</span>
<span class="normal">299</span>
<span class="normal">300</span>
<span class="normal">301</span>
<span class="normal">302</span>
<span class="normal">303</span>
<span class="normal">304</span>
<span class="normal">305</span>
<span class="normal">306</span>
<span class="normal">307</span>
<span class="normal">308</span>
<span class="normal">309</span>
<span class="normal">310</span>
<span class="normal">311</span>
<span class="normal">312</span>
<span class="normal">313</span>
<span class="normal">314</span>
<span class="normal">315</span>
<span class="normal">316</span>
<span class="normal">317</span>
<span class="normal">318</span>
<span class="normal">319</span>
<span class="normal">320</span>
<span class="normal">321</span>
<span class="normal">322</span>
<span class="normal">323</span>
<span class="normal">324</span>
<span class="normal">325</span>
<span class="normal">326</span>
<span class="normal">327</span>
<span class="normal">328</span>
<span class="normal">329</span></pre></div></td><td class="code"><div><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">split</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reader_output</span><span class="p">:</span> <span class="n">ReaderOutput</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">SplitterOutput</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Split the document text into semantically coherent chunks.</span>

<span class="sd">    Args:</span>
<span class="sd">        reader_output (ReaderOutput): The document text &amp; metadata.</span>

<span class="sd">    Returns:</span>
<span class="sd">        SplitterOutput: Chunks, IDs, metadata, and splitter configuration.</span>

<span class="sd">    Notes:</span>
<span class="sd">        - With 1 sentence (or 2 in gradient mode), returns the text/sentences as-is.</span>
<span class="sd">        - Chunks shorter than `chunk_size` (minimum) are skipped and merged forward.</span>
<span class="sd">        - `chunk_size` behaves as the *minimum* chunk size in this splitter.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">text</span> <span class="o">=</span> <span class="n">reader_output</span><span class="o">.</span><span class="n">text</span>
    <span class="k">if</span> <span class="n">text</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">or</span> <span class="n">text</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;No text has been provided&quot;</span><span class="p">)</span>

    <span class="n">amt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span>
    <span class="k">if</span> <span class="p">(</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;percentile&quot;</span><span class="p">,</span> <span class="s2">&quot;gradient&quot;</span><span class="p">)</span>
        <span class="ow">and</span> <span class="mf">0.0</span> <span class="o">&lt;</span> <span class="n">amt</span> <span class="o">&lt;=</span> <span class="mf">1.0</span>  <span class="c1"># noqa: W503</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span> <span class="o">=</span> <span class="n">amt</span> <span class="o">*</span> <span class="mf">100.0</span>

    <span class="n">sentences</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_split_into_sentences</span><span class="p">(</span><span class="n">reader_output</span><span class="p">)</span>

    <span class="c1"># Edge cases where thresholds aren&#39;t meaningful</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">sentences</span> <span class="k">if</span> <span class="n">sentences</span> <span class="k">else</span> <span class="p">[</span><span class="n">text</span><span class="p">]</span>
    <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span> <span class="o">==</span> <span class="s2">&quot;gradient&quot;</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
        <span class="n">chunks</span> <span class="o">=</span> <span class="n">sentences</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">distances</span><span class="p">,</span> <span class="n">sentence_dicts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_sentence_distances</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">distances</span><span class="p">:</span>
            <span class="c1"># Pick top (k-1) distances as breakpoints</span>
            <span class="n">k</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">min</span><span class="p">(</span><span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">distances</span><span class="p">)))</span>  <span class="c1"># number of cuts to make</span>
            <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">indices_above</span> <span class="o">=</span> <span class="p">[]</span>  <span class="c1"># single chunk</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># indices of the m largest distances (breaks), sorted in ascending order</span>
                <span class="n">idxs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">distances</span><span class="p">))[</span><span class="o">-</span><span class="n">m</span><span class="p">:]</span>
                <span class="n">indices_above</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idxs</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">threshold</span><span class="p">,</span> <span class="n">ref_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_calculate_breakpoint_threshold</span><span class="p">(</span><span class="n">distances</span><span class="p">)</span>
            <span class="n">indices_above</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">i</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">ref_array</span><span class="p">)</span> <span class="k">if</span> <span class="n">val</span> <span class="o">&gt;</span> <span class="n">threshold</span>
            <span class="p">]</span>

        <span class="n">chunks</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">start_idx</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">indices_above</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="n">idx</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># inclusive slice end</span>
            <span class="n">candidate</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sentence&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sentence_dicts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">:</span>
                <span class="c1"># too small: keep accumulating (do NOT move start_idx)</span>
                <span class="k">continue</span>
            <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">candidate</span><span class="p">)</span>
            <span class="n">start_idx</span> <span class="o">=</span> <span class="n">end</span>

        <span class="c1"># Tail (always emit whatever remains)</span>
        <span class="k">if</span> <span class="n">start_idx</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">sentence_dicts</span><span class="p">):</span>
            <span class="n">tail</span> <span class="o">=</span> <span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">d</span><span class="p">[</span><span class="s2">&quot;sentence&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">sentence_dicts</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">tail</span><span class="p">:</span>
                <span class="n">chunks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tail</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">chunks</span><span class="p">:</span>
            <span class="n">chunks</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sentences</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="ow">or</span> <span class="p">(</span><span class="n">reader_output</span><span class="o">.</span><span class="n">text</span> <span class="ow">or</span> <span class="s2">&quot;&quot;</span><span class="p">)]</span>

    <span class="c1"># IDs &amp; metadata</span>
    <span class="n">chunk_ids</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_generate_chunk_ids</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">chunks</span><span class="p">))</span>
    <span class="n">metadata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_default_metadata</span><span class="p">()</span>
    <span class="n">model_name</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embedding</span><span class="p">,</span> <span class="s2">&quot;model_name&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">SplitterOutput</span><span class="p">(</span>
        <span class="n">chunks</span><span class="o">=</span><span class="n">chunks</span><span class="p">,</span>
        <span class="n">chunk_id</span><span class="o">=</span><span class="n">chunk_ids</span><span class="p">,</span>
        <span class="n">document_name</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_name</span><span class="p">,</span>
        <span class="n">document_path</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_path</span><span class="p">,</span>
        <span class="n">document_id</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">document_id</span><span class="p">,</span>
        <span class="n">conversion_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">conversion_method</span><span class="p">,</span>
        <span class="n">reader_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">reader_method</span><span class="p">,</span>
        <span class="n">ocr_method</span><span class="o">=</span><span class="n">reader_output</span><span class="o">.</span><span class="n">ocr_method</span><span class="p">,</span>
        <span class="n">split_method</span><span class="o">=</span><span class="s2">&quot;semantic_splitter&quot;</span><span class="p">,</span>
        <span class="n">split_params</span><span class="o">=</span><span class="p">{</span>
            <span class="s2">&quot;buffer_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">buffer_size</span><span class="p">,</span>
            <span class="s2">&quot;breakpoint_threshold_type&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_type</span><span class="p">,</span>
            <span class="s2">&quot;breakpoint_threshold_amount&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">breakpoint_threshold_amount</span><span class="p">,</span>
            <span class="s2">&quot;number_of_chunks&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_chunks</span><span class="p">,</span>
            <span class="s2">&quot;chunk_size&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">chunk_size</span><span class="p">,</span>
            <span class="s2">&quot;model_name&quot;</span><span class="p">:</span> <span class="n">model_name</span><span class="p">,</span>
        <span class="p">},</span>
        <span class="n">metadata</span><span class="o">=</span><span class="n">metadata</span><span class="p">,</span>
    <span class="p">)</span>
</code></pre></div></td></tr></table></div>
            </details>
    </div>

</div>



  </div>

    </div>

</div>




  </div>

    </div>

</div>












                
              </article>
            </div>
          
          
<script>var target=document.getElementById(location.hash.slice(1));target&&target.name&&(target.checked=target.name.startsWith("__tabbed_"))</script>
        </div>
        
      </main>
      
        <footer class="md-footer">
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-copyright">
  
  
    Made with
    <a href="https://squidfunk.github.io/mkdocs-material/" target="_blank" rel="noopener">
      Material for MkDocs
    </a>
  
</div>
      
    </div>
  </div>
</footer>
      
    </div>
    <div class="md-dialog" data-md-component="dialog">
      <div class="md-dialog__inner md-typeset"></div>
    </div>
    
    
    
      
      <script id="__config" type="application/json">{"base": "../..", "features": ["content.code.copy"], "search": "../../assets/javascripts/workers/search.973d3a69.min.js", "tags": null, "translations": {"clipboard.copied": "Copied to clipboard", "clipboard.copy": "Copy to clipboard", "search.result.more.one": "1 more on this page", "search.result.more.other": "# more on this page", "search.result.none": "No matching documents", "search.result.one": "1 matching document", "search.result.other": "# matching documents", "search.result.placeholder": "Type to start searching", "search.result.term.missing": "Missing", "select.version": "Select version"}, "version": null}</script>
    
    
      <script src="../../assets/javascripts/bundle.92b07e13.min.js"></script>
      
        <script src="../../javascripts/katex.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/katex.min.js"></script>
      
        <script src="https://unpkg.com/katex@0/dist/contrib/auto-render.min.js"></script>
      
    
  </body>
</html>